import * as React from "react";
import { $State } from "../states";
interface Variants {
    [vg: string]: any;
}
export declare type MultiChoiceArg<M extends string> = M | M[] | {
    [v in M]?: boolean;
};
export declare type SingleChoiceArg<M extends string> = M;
export declare type SingleBooleanChoiceArg<M extends string> = M | boolean;
interface OverrideTwiddle {
    wrapChildren?: (children: React.ReactNode) => React.ReactNode;
    wrap?: (node: React.ReactNode) => React.ReactNode;
}
export declare type DefaultOverride<C extends React.ElementType> = {
    type: "default";
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type AsOverride<C extends React.ElementType> = {
    type: "as";
    as: C;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type RenderOverride<C extends React.ElementType> = {
    type: "render";
    render: (props: React.ComponentProps<C>, Comp: C) => React.ReactNode;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type Override<DefaultElementType extends React.ElementType> = DefaultOverride<DefaultElementType> | AsOverride<any> | RenderOverride<DefaultElementType>;
export declare type Overrides = Record<string, Flex<any>>;
export declare type Args = Record<string, any>;
export declare type Flex<DefaultElementType extends React.ElementType> = (Omit<DefaultOverride<DefaultElementType>, "type"> & {
    as?: never;
    render?: never;
}) | Omit<AsOverride<any>, "type"> | (Omit<RenderOverride<DefaultElementType>, "type"> & {
    as?: never;
}) | React.ReactChild | null | undefined | (Partial<React.ComponentProps<DefaultElementType>> & {
    wrap?: never;
    wrapChildren?: never;
    props?: never;
    as?: never;
    render?: never;
}) | ((props: React.ComponentProps<DefaultElementType>) => React.ReactNode);
export declare function hasVariant<V extends Variants>(variants: V | undefined, groupName: keyof V, variant: string): any;
export declare function wrapFlexContainerChildren(children: React.ReactNode, hasGap: boolean): React.DetailedReactHTMLElement<{
    className: string;
}, HTMLElement> | null;
export declare function createPlasmicElementProxy<DefaultElementType extends React.ElementType>(defaultElement: DefaultElementType, props: Partial<React.ComponentProps<DefaultElementType>>, ...children: React.ReactNode[]): number | boolean | React.ReactElement<any, string | ((props: any) => React.ReactElement<any, any> | null) | (new (props: any) => React.Component<any, any, any>)> | React.ReactFragment | null | undefined;
export declare function makeFragment(...children: React.ReactNode[]): React.FunctionComponentElement<{
    children?: React.ReactNode;
}>;
export declare const UNSET: unique symbol;
export declare function wrapWithClassName(element: React.ReactNode, className: string): React.DetailedReactHTMLElement<{
    key: string | number | undefined;
    className: string;
    style: {
        display: "grid";
    };
}, HTMLElement>;
export declare function mergeVariantsWithStates(variants: Variants, $state: $State, linkedStates: {
    variantGroup: string;
    statePath: (string | number)[];
}[]): Variants;
export declare function deriveRenderOpts(props: Record<string, any>, config: {
    name: string;
    descendantNames: string[];
    internalVariantPropNames: string[];
    internalArgPropNames: string[];
}): {
    variants: Partial<Partial<Record<string, any>>>;
    args: Partial<Partial<Record<string, any>>>;
    overrides: Partial<Partial<Record<string, any>>>;
};
export {};
