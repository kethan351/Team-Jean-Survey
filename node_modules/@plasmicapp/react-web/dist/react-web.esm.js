import classNames$1 from 'classnames';
import { usePlasmicDataSourceContext, PlasmicDataSourceContextProvider } from '@plasmicapp/data-sources-context';
export { PlasmicDataSourceContextProvider, useCurrentUser } from '@plasmicapp/data-sources-context';
import * as React from 'react';
import React__default, { forwardRef, createElement, Fragment, isValidElement, useContext, createContext, useState, useRef, useMemo, useLayoutEffect, useEffect, useImperativeHandle, useCallback, cloneElement } from 'react';
import _get from 'dlv';
export { default as get } from 'dlv';
import ReactDOM__default, { createPortal } from 'react-dom';
import { SSRProvider, useIsSSR as useIsSSR$1 } from '@react-aria/ssr';
import { useFocusRing, useFocusable, FocusScope } from '@react-aria/focus';
import clone from 'clone';
import deepEqual from 'fast-deep-equal';
import { proxy, useSnapshot, ref } from 'valtio';
import { useCheckbox as useCheckbox$1 } from '@react-aria/checkbox';
import { VisuallyHidden } from '@react-aria/visually-hidden';
import { useToggleState } from '@react-stately/toggle';
import { useMenu as useMenu$1, useMenuSection, useMenuItem as useMenuItem$1, useMenuTrigger as useMenuTrigger$1 } from '@react-aria/menu';
import { useTreeState } from '@react-stately/tree';
import { Item, Section } from '@react-stately/collections';
import { useSeparator } from '@react-aria/separator';
import { useMenuTriggerState } from '@react-stately/menu';
import { usePress } from '@react-aria/interactions';
import { usePlasmicCanvasContext } from '@plasmicapp/host';
import { useListBox, useOption, useListBoxSection } from '@react-aria/listbox';
import { useSelect as useSelect$1, HiddenSelect } from '@react-aria/select';
import { useSelectState } from '@react-stately/select';
import { useSwitch as useSwitch$1 } from '@react-aria/switch';
import { useOverlay, useOverlayPosition, DismissButton } from '@react-aria/overlays';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;
        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function (object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }
              next.value = undefined$1;
              next.done = true;
              return next;
            };
          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return {
        next: doneResult
      };
    }
    exports.values = values;
    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }
    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;
  }(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
});

// https://stackoverflow.com/a/2117523
function uuidv4() {
  // @ts-ignore
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (c) {
    return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
  });
}
function triggerLogin(_x, _x2, _x3) {
  return _triggerLogin.apply(this, arguments);
}
function _triggerLogin() {
  _triggerLogin = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(appId, authorizeEndpoint, redirectUri) {
    var sha256, _sha, continueTo, state, code_verifier, code_challenge, params, url;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _sha = function _sha3() {
              _sha = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(text) {
                var encoder, data, hashBuffer, hashArray, hashHex;
                return runtime_1.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        encoder = new TextEncoder();
                        data = encoder.encode(text);
                        _context.next = 4;
                        return crypto.subtle.digest("SHA-256", data);
                      case 4:
                        hashBuffer = _context.sent;
                        hashArray = Array.from(new Uint8Array(hashBuffer));
                        hashHex = hashArray.map(function (b) {
                          return b.toString(16).padStart(2, "0");
                        }).join("");
                        return _context.abrupt("return", hashHex);
                      case 8:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return _sha.apply(this, arguments);
            };
            sha256 = function _sha2(_x4) {
              return _sha.apply(this, arguments);
            };
            continueTo = window.location.href;
            state = JSON.stringify({
              continueTo: continueTo
            });
            code_verifier = uuidv4();
            localStorage.setItem("code_verifier", code_verifier);
            _context2.next = 8;
            return sha256(code_verifier);
          case 8:
            code_challenge = _context2.sent;
            params = new URLSearchParams();
            params.set("client_id", appId);
            params.set("state", state);
            params.set("response_type", "code");
            params.set("code_challenge", code_challenge);
            params.set("code_challenge_method", "S256");
            if (redirectUri) {
              params.set("redirect_uri", redirectUri);
            }
            url = authorizeEndpoint + "?" + params.toString();
            window.location.href = url;
          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _triggerLogin.apply(this, arguments);
}
function PlasmicPageGuard(props) {
  var appId = props.appId,
    authorizeEndpoint = props.authorizeEndpoint,
    minRole = props.minRole,
    canTriggerLogin = props.canTriggerLogin,
    children = props.children;
  var dataSourceCtxValue = usePlasmicDataSourceContext();
  React__default.useEffect(function () {
    if (canTriggerLogin) {
      if (minRole && dataSourceCtxValue && "isUserLoading" in dataSourceCtxValue && !dataSourceCtxValue.isUserLoading && !dataSourceCtxValue.user) {
        triggerLogin(appId, authorizeEndpoint, dataSourceCtxValue.authRedirectUri);
      }
    }
  }, [dataSourceCtxValue, appId, authorizeEndpoint, canTriggerLogin, minRole]);
  function canUserViewPage() {
    if (!minRole) {
      return true;
    }
    if (!dataSourceCtxValue) {
      return false;
    }
    if (!dataSourceCtxValue.user) {
      return false;
    }
    if (!("roleIds" in dataSourceCtxValue.user)) {
      return false;
    }
    if (!Array.isArray(dataSourceCtxValue.user.roleIds)) {
      return false;
    }
    return dataSourceCtxValue.user.roleIds.includes(minRole);
  }
  if (!dataSourceCtxValue || dataSourceCtxValue.isUserLoading || !dataSourceCtxValue.user && minRole && canTriggerLogin) {
    return null;
  }
  if (!canUserViewPage()) {
    return React__default.createElement("div", null, "You don't have access to this page");
  }
  return children;
}

function notNil(x) {
  return x != null;
}
function pick(obj) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }
  var res = {};
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
}
function pickBy(obj, func) {
  var res = {};
  for (var _i2 = 0, _Object$entries = Object.entries(obj); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _Object$entries[_i2],
      key = _Object$entries$_i[0],
      val = _Object$entries$_i[1];
    if (func(key, val)) {
      res[key] = obj[key];
    }
  }
  return res;
}
function omit(obj) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }
  var res = {};
  for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    keys[_key2 - 1] = arguments[_key2];
  }
  for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {
    var key = _Object$keys[_i3];
    if (!keys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}
function isSubset(a1, a2) {
  return a1.every(function (x) {
    return a2.includes(x);
  });
}
function chainSingleArgFuncs() {
  for (var _len3 = arguments.length, funcs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    funcs[_key3] = arguments[_key3];
  }
  if (funcs.length === 0) {
    return undefined;
  }
  return function (arg) {
    var res = arg;
    for (var _i4 = 0, _funcs = funcs; _i4 < _funcs.length; _i4++) {
      var func = _funcs[_i4];
      res = func(res);
    }
    return res;
  };
}
function isString(x) {
  return typeof x === "string";
}
function groupBy(collection, keyFunc) {
  var result = {};
  for (var _iterator = _createForOfIteratorHelperLoose(collection), _step; !(_step = _iterator()).done;) {
    var obj = _step.value;
    var key = keyFunc(obj);
    if (key in result) {
      result[key].push(obj);
    } else {
      result[key] = [obj];
    }
  }
  return result;
}
function mapValues(obj, mapper) {
  var result = {};
  for (var key in obj) {
    result[key] = mapper(obj[key]);
  }
  return result;
}

var isBrowser = typeof window !== "undefined";
var NONE = /*#__PURE__*/Symbol("NONE");
var useIsomorphicLayoutEffect = isBrowser ? React__default.useLayoutEffect : React__default.useEffect;
function createElementWithChildren(elementType, props, children) {
  if (Array.isArray(children)) {
    return React__default.createElement.apply(React__default, [elementType, props].concat(children));
  } else if (children || "children" in props) {
    // Only call React.createElement with `children` if there are actual children,
    // or if there was an explicit (albeit undefined) children passed via
    // props.  Otherwise, if you pass `undefined` as the children argument
    // to React.createElement, the created element will have prop {children: undefined}.
    // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}
    // are used, then it will be taken as a `children` override, and will thus blank out
    // everything under the root node.
    return React__default.createElement(elementType, props, children);
  } else {
    return React__default.createElement(elementType, props);
  }
}
function ensureNotArray(children) {
  if (Array.isArray(children)) {
    if (children.length === 1) {
      return children[0];
    } else {
      return React__default.createElement.apply(React__default, [React__default.Fragment, {}].concat(children));
    }
  } else {
    return children;
  }
}
/**
 * Flattens ReactNode into an array of ReactChild, but does NOT replace
 * missing keys with array index, as React.Children.toArray() does.
 */
function toChildArray(children) {
  if (isReactChild(children)) {
    return [children];
  } else if (Array.isArray(children)) {
    return children.flatMap(toChildArray);
  } else {
    return [];
  }
}
function isReactText(child) {
  return typeof child === "string" || typeof child === "number";
}
function isReactChild(child) {
  return React__default.isValidElement(child) || isReactText(child);
}
function isReactNode(x) {
  return typeof x === "string" || typeof x === "number" || React__default.isValidElement(x);
}
function mergeProps(props) {
  for (var _len = arguments.length, restProps = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restProps[_key - 1] = arguments[_key];
  }
  if (restProps.every(function (rest) {
    return Object.keys(rest).length === 0;
  })) {
    return props;
  }
  var result = _extends({}, props);
  for (var _i = 0, _restProps = restProps; _i < _restProps.length; _i++) {
    var rest = _restProps[_i];
    for (var _i2 = 0, _Object$keys = Object.keys(rest); _i2 < _Object$keys.length; _i2++) {
      var key = _Object$keys[_i2];
      result[key] = mergePropVals(key, result[key], rest[key]);
    }
  }
  return result;
}
function updateRef(ref, value) {
  if (!ref) {
    return;
  }
  if (typeof ref === "function") {
    ref(value);
  } else {
    if (!Object.isFrozen(ref)) {
      ref.current = value;
    }
  }
}
function mergeRefs() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return function (value) {
    for (var _i3 = 0, _refs = refs; _i3 < _refs.length; _i3++) {
      var ref = _refs[_i3];
      updateRef(ref, value);
    }
  };
}
function mergePropVals(name, val1, val2) {
  if (val1 === NONE || val2 === NONE) {
    // The NONE sentinel always skips all merging and returns null
    return null;
  } else if (val1 == null) {
    // If either of them is nil, prefer the other
    return val2;
  } else if (val2 == null) {
    return val1;
  } else if (name === "className") {
    // Special case for className -- always combine both class names
    return classNames$1(val1, val2);
  } else if (name === "style") {
    // Special case for style -- always shallow-merge style dicts
    return _extends({}, val1, val2);
  } else if (name === "ref") {
    // Special case for ref
    return mergeRefs(val1, val2);
  } else if (typeof val1 !== typeof val2) {
    // If the type of the two values are different, then no way to merge them.
    // Prefer val2.
    return val2;
  } else if (name.startsWith("on") && typeof val1 === "function") {
    // Special case for event handlers -- always call both handlers
    return function () {
      var res;
      if (typeof val1 === "function") {
        res = val1.apply(void 0, arguments);
      }
      if (typeof val2 === "function") {
        res = val2.apply(void 0, arguments);
      }
      return res;
    };
  } else {
    // For all else, prefer val2
    return val2;
  }
}
function getElementTypeName(element) {
  if (typeof element.type === "string") {
    return element.type;
  } else {
    var _ref, _ref2, _comp$displayName, _comp$render;
    var comp = element.type;
    return (_ref = (_ref2 = (_comp$displayName = comp.displayName) != null ? _comp$displayName : comp.name) != null ? _ref2 : (_comp$render = comp.render) == null ? void 0 : _comp$render.name) != null ? _ref : "Component";
  }
}

var _excluded = ["children"],
  _excluded2 = ["as", "hasGap"],
  _excluded3 = ["hasGap"];
function renderStack(as, props, hasGap, ref) {
  var children = props.children,
    rest = _objectWithoutPropertiesLoose(props, _excluded);
  var wrappedChildren = wrapFlexContainerChildren(children, hasGap != null ? hasGap : false);
  return createElementWithChildren(as, _extends({
    ref: ref
  }, rest), wrappedChildren);
}
function FlexStack_(props, outerRef) {
  var as = props.as,
    hasGap = props.hasGap,
    rest = _objectWithoutPropertiesLoose(props, _excluded2);
  return renderStack(as != null ? as : "div", rest, hasGap, outerRef);
}
var FlexStack = /*#__PURE__*/forwardRef(FlexStack_);
var makeStackImpl = function makeStackImpl(as) {
  return forwardRef(function (props, ref) {
    var hasGap = props.hasGap,
      rest = _objectWithoutPropertiesLoose(props, _excluded3);
    return renderStack(as, rest, hasGap, ref);
  });
};
var Stack = /*#__PURE__*/Object.assign(FlexStack, {
  div: /*#__PURE__*/makeStackImpl("div"),
  a: /*#__PURE__*/makeStackImpl("a"),
  button: /*#__PURE__*/makeStackImpl("button"),
  h1: /*#__PURE__*/makeStackImpl("h1"),
  h2: /*#__PURE__*/makeStackImpl("h2"),
  h3: /*#__PURE__*/makeStackImpl("h3"),
  h4: /*#__PURE__*/makeStackImpl("h4"),
  h5: /*#__PURE__*/makeStackImpl("h5"),
  h6: /*#__PURE__*/makeStackImpl("h6"),
  label: /*#__PURE__*/makeStackImpl("label"),
  form: /*#__PURE__*/makeStackImpl("form"),
  section: /*#__PURE__*/makeStackImpl("section"),
  head: /*#__PURE__*/makeStackImpl("head"),
  main: /*#__PURE__*/makeStackImpl("main"),
  nav: /*#__PURE__*/makeStackImpl("nav")
});

function hasVariant(variants, groupName, variant) {
  if (variants == null) {
    return false;
  }
  var groupVariants = variants[groupName];
  if (groupVariants == null) {
    return false;
  } else if (groupVariants === true) {
    return variant === groupName;
  } else if (groupVariants === false) {
    return false;
  } else if (Array.isArray(groupVariants)) {
    return groupVariants.includes(variant);
  } else if (typeof groupVariants === "string") {
    return groupVariants === variant;
  } else {
    return groupVariants[variant] !== undefined && groupVariants[variant] !== false;
  }
}
function wrapFlexContainerChildren(children, hasGap) {
  // We need to always wrap the children, even if there are no gaps, because
  // otherwise if we toggle between with and without gap, React reconciliation
  // will blow away the children tree and all state if we switch from having
  // a wrapper and not.
  var className = hasGap ? "__wab_flex-container" : "__wab_passthrough";
  if (!children) {
    return null;
  } else if (Array.isArray(children)) {
    return createElement.apply(React, ["div", {
      className: className
    }].concat(children));
  } else {
    return createElement("div", {
      className: className
    }, children);
  }
}
function createPlasmicElement(override, defaultRoot, defaultProps, wrapChildrenInFlex) {
  if (!override || Object.keys(override).length === 0) {
    return createElementWithChildren(defaultRoot, defaultProps, defaultProps.children);
  }
  var override2 = deriveOverride(override);
  var props = mergeOverrideProps(defaultProps, override2.props);
  if (override2.type === "render") {
    return override2.render(props, defaultRoot);
  }
  var root = defaultRoot;
  if (override2.type === "as" && override2.as) {
    if (defaultRoot === Stack) {
      // If there was an "as" override specified, but the default type is
      // a Stack, then we don't want to switch to using "as" as the root,
      // because then we'd lose the flex wrapper that Stack provides.
      // Instead, we specify the "as" as the "as" prop to Stack.
      props.as = override2.as;
    } else {
      root = override2.as;
    }
  }
  var children = props.children;
  if (override2.wrapChildren) {
    children = override2.wrapChildren(ensureNotArray(children));
  }
  if (wrapChildrenInFlex) {
    // For legacy, we still support data-plasmic-wrap-flex-children
    children = wrapFlexContainerChildren(children, true);
  }
  var result = createElementWithChildren(root, props, children);
  if (override2.wrap) {
    result = override2.wrap(result);
  }
  return result;
}
// We use data-plasmic-XXX attributes for custom properties since Typescript doesn't
// support type check on jsx pragma. See https://github.com/microsoft/TypeScript/issues/21699
// for more info.
var seenElements = /*#__PURE__*/new Map();
function createPlasmicElementProxy(defaultElement, props) {
  // We use seenElements to keep track of elements that has been rendered by
  // createPlasmicElementProxy().  When a JSX tree is evaluated, the JSX factory
  // is invoked from the leaf to the root as the last call.  So we can store
  // all the elements we've created until we encounter the leaf, at which point
  // we will clear this map.  We are guaranteed that this map will only contain
  // elements from one Plasmic* component at a time, because we're just creating
  // elements and not "rendering" at this point; even if this JSX tree references
  // other Plasmic* elements, we'll just create an element referencing that component,
  // rather than following into the content of that component.
  //
  // TODO: is this ConcurrentMode friendly?
  if (props == null) {
    props = {};
  }
  var name = props["data-plasmic-name"];
  var isRoot = props["data-plasmic-root"];
  var forNodeName = props["data-plasmic-for-node"];
  delete props["data-plasmic-name"];
  delete props["data-plasmic-root"];
  delete props["data-plasmic-for-node"];
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  var element = createPlasmicElementFromJsx.apply(void 0, [defaultElement, props].concat(children));
  if (name) {
    seenElements.set(name, element);
  }
  if (isRoot) {
    var _seenElements$get;
    // If this is the root, and we requested a specific node by specifying data-plasmic-for-node,
    // then return that node instead
    var forNode = forNodeName ? (_seenElements$get = seenElements.get(forNodeName)) != null ? _seenElements$get : null : element;
    // Clear out the seenElements map, as we're done rendering this Plasmic* component.
    seenElements.clear();
    return forNode;
  }
  return element;
}
function createPlasmicElementFromJsx(defaultElement, props) {
  var _props$dataPlasmicT;
  var override = props["data-plasmic-override"];
  var wrapFlexChild = props["data-plasmic-wrap-flex-child"];
  var triggerProps = (_props$dataPlasmicT = props["data-plasmic-trigger-props"]) != null ? _props$dataPlasmicT : [];
  delete props["data-plasmic-override"];
  delete props["data-plasmic-wrap-flex-child"];
  delete props["data-plasmic-trigger-props"];
  for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    children[_key2 - 2] = arguments[_key2];
  }
  return createPlasmicElement(override, defaultElement, mergeProps.apply(void 0, [props, children.length === 0 ? {} : {
    children: children.length === 1 ? children[0] : children
  }].concat(triggerProps)), wrapFlexChild);
}
function makeFragment() {
  for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    children[_key3] = arguments[_key3];
  }
  return createElement.apply(React, [Fragment, {}].concat(children));
}
var UNSET = /*#__PURE__*/Symbol("UNSET");
function mergeOverrideProps(defaults, overrides) {
  if (!overrides) {
    return defaults;
  }
  var result = _extends({}, defaults);
  for (var _i = 0, _Object$keys = Object.keys(overrides); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var defaultVal = defaults[key];
    var overrideVal = overrides[key];
    if (overrideVal === UNSET) {
      delete result[key];
    } else {
      // We use the NONE sentinel if the overrideVal is nil, and is not one of the
      // props that we merge by default -- which are className, style, and
      // event handlers.  This means for all other "normal" props -- like children,
      // title, etc -- a nil value will unset the default.
      if (overrideVal == null && key !== "className" && key !== "style" && !(key.startsWith("on") && typeof defaultVal === "function")) {
        overrideVal = NONE;
      }
      result[key] = mergePropVals(key, defaultVal, overrideVal);
    }
  }
  return result;
}
function wrapWithClassName(element, className) {
  var key = isValidElement(element) ? element.key || undefined : undefined;
  return createElement("div", {
    key: key,
    className: className,
    style: {
      display: "grid"
    }
  }, element);
}
function deriveOverride(x) {
  if (!x) {
    // undefined Binding is an empty Binding
    return {
      type: "default",
      props: {}
    };
  } else if (isReactNode(x)) {
    // If ReactNode, then assume this is the children
    return {
      type: "default",
      props: {
        children: x
      }
    };
  } else if (typeof x === "object") {
    // If any of the overrideKeys is a key of this object, then assume
    // this is a full Override
    if ("as" in x) {
      return _extends({}, x, {
        props: x.props || {},
        type: "as"
      });
    } else if ("render" in x) {
      return _extends({}, x, {
        type: "render"
      });
    } else if ("props" in x) {
      return _extends({}, x, {
        props: x.props || {},
        type: "default"
      });
    } else if (isSubset(Object.keys(x), ["wrap", "wrapChildren"])) {
      // Only twiddling functions present, so assume no props overrides
      // (otherwise we'd assume these were props).
      return _extends({}, x, {
        props: {},
        type: "default"
      });
    }
    // Else, assume this is just a props object.
    return {
      type: "default",
      props: x
    };
  } else if (typeof x === "function") {
    return {
      type: "render",
      render: x
    };
  }
  throw new Error("Unexpected override: " + x);
}
function mergeVariants(v1, v2) {
  if (!v1 || !v2) {
    return v1 || v2 || {};
  }
  return _extends({}, v1, v2);
}
function mergeVariantsWithStates(variants, $state, linkedStates) {
  return _extends({}, variants, Object.fromEntries(linkedStates.map(function (_ref) {
    var variantGroup = _ref.variantGroup,
      statePath = _ref.statePath;
    return [variantGroup, _get($state, statePath)];
  })));
}
function mergeArgs(a1, a2) {
  if (!a1 || !a2) {
    return a1 || a2 || {};
  }
  return _extends({}, a1, a2);
}
function mergeFlexOverrides(o1, o2) {
  if (!o2) {
    return o1;
  }
  var keys = Array.from(new Set([].concat(Object.keys(o1), Object.keys(o2))));
  var merged = {};
  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
    var key = _keys[_i2];
    merged[key] = mergeFlexOverride(o1[key], o2[key]);
  }
  return merged;
}
function mergeFlexOverride(fo1, fo2) {
  var _o1$props, _ref2;
  if (!fo1) {
    return fo2;
  }
  if (!fo2) {
    return fo1;
  }
  var o1 = deriveOverride(fo1);
  var o2 = deriveOverride(fo2);
  var wrap = chainSingleArgFuncs.apply(void 0, [o1.wrap, o2.wrap].filter(notNil));
  var wrapChildren = chainSingleArgFuncs.apply(void 0, [o1.wrapChildren, o2.wrapChildren].filter(notNil));
  // "render" type always takes precedence, but we still merge the props
  var props = mergeOverrideProps((_o1$props = o1.props) != null ? _o1$props : {}, o2.props);
  if (o2.type === "render") {
    return {
      render: o2.render,
      props: props,
      wrap: wrap,
      wrapChildren: wrapChildren
    };
  }
  if (o1.type === "render") {
    return {
      render: o1.render,
      props: props,
      wrap: wrap,
      wrapChildren: wrapChildren
    };
  }
  // "as" will take precedence
  var as = (_ref2 = o2.type === "as" ? o2.as : undefined) != null ? _ref2 : o1.type === "as" ? o1.as : undefined;
  return _extends({
    props: props,
    wrap: wrap,
    wrapChildren: wrapChildren
  }, as ? {
    as: as
  } : {});
}
function deriveRenderOpts(props, config) {
  var name = config.name,
    descendantNames = config.descendantNames,
    internalVariantPropNames = config.internalVariantPropNames,
    internalArgPropNames = config.internalArgPropNames;
  var reservedPropNames = ["variants", "args", "overrides"];
  var variants = mergeVariants(omit.apply(void 0, [pick.apply(void 0, [props].concat(internalVariantPropNames))].concat(reservedPropNames)), props.variants);
  var args = mergeArgs(omit.apply(void 0, [pick.apply(void 0, [props].concat(internalArgPropNames))].concat(reservedPropNames)), props.args);
  var overrides = mergeFlexOverrides(omit.apply(void 0, [pick.apply(void 0, [props].concat(descendantNames))].concat(internalArgPropNames, internalVariantPropNames, reservedPropNames)), props.overrides);
  var leftoverProps = omit.apply(void 0, [props, "variants", "args", "overrides"].concat(descendantNames, internalVariantPropNames, internalArgPropNames));
  if (Object.keys(leftoverProps).length > 0) {
    var _mergeFlexOverrides;
    overrides = mergeFlexOverrides(overrides, (_mergeFlexOverrides = {}, _mergeFlexOverrides[name] = {
      props: leftoverProps
    }, _mergeFlexOverrides));
  }
  return {
    variants: variants,
    args: args,
    overrides: overrides
  };
}

var isDefaultValue = function isDefaultValue(val) {
  return val === "PLEASE_RENDER_INSIDE_PROVIDER";
};
var seenDefaultVariants = {};
function ensureGlobalVariants(globalVariantValues) {
  Object.entries(globalVariantValues).filter(function (_ref) {
    var value = _ref[1];
    return isDefaultValue(value);
  }).forEach(function (_ref2) {
    var key = _ref2[0];
    globalVariantValues[key] = undefined;
    if (!seenDefaultVariants[key] && process.env.NODE_ENV === "development") {
      seenDefaultVariants[key] = true;
      var providerName = "" + key[0].toUpperCase() + key.substring(1) + "Context.Provider";
      console.warn("Plasmic context value for global variant \"" + key + "\" was not provided; please use " + providerName + " at the root of your React app. Learn More: https://www.plasmic.app/learn/other-assets/#global-variants");
    }
  });
  return globalVariantValues;
}

var PlasmicHeadContext = /*#__PURE__*/createContext(undefined);
function PlasmicHead(props) {
  var Head = useContext(PlasmicHeadContext);
  if (!Head) {
    console.warn("Plasmic: Head meta tags are being ignored. To make them work, pass a Head component into PlasmicRootProvider.");
    // TODO: Link to doc about Head.
    return null;
  }
  // Helmet does not support React.Fragments, so we need to use `[<meta />,
  // <meta />]` instead of `<><meta /><meta /></>`.
  return createElement(Head, null, props.image ? [createElement("meta", {
    key: "twitter:card",
    name: "twitter:card",
    content: "summary_large_image"
  }), createElement("meta", {
    key: "og:image",
    property: "og:image",
    content: props.image
  }), createElement("meta", {
    key: "twitter:image",
    name: "twitter:image",
    content: props.image
  })] : createElement("meta", {
    key: "twitter:card",
    name: "twitter:card",
    content: "summary"
  }), props.title && [createElement("title", {
    key: "title"
  }, props.title), createElement("meta", {
    key: "og:title",
    property: "og:title",
    content: props.title
  }), createElement("meta", {
    key: "twitter:title",
    property: "twitter:title",
    content: props.title
  })], props.description && [createElement("meta", {
    key: "description",
    name: "description",
    content: props.description
  }), createElement("meta", {
    key: "og:description",
    property: "og:description",
    content: props.description
  }), createElement("meta", {
    key: "twitter:description",
    name: "twitter:description",
    content: props.description
  })], props.canonical && createElement("link", {
    key: "canonical",
    ref: "canonical",
    href: props.canonical
  }));
}
var plasmicHeadMeta = {
  name: "hostless-plasmic-head",
  displayName: "Head",
  description: "Used to add page metadata to HTML <head />.",
  importName: "PlasmicHead",
  importPath: "@plasmicapp/react-web",
  isRepeatable: false,
  styleSections: false,
  props: {
    title: {
      type: "string",
      displayName: "Title"
    },
    description: {
      type: "string",
      displayName: "Description"
    },
    image: {
      type: "imageUrl",
      displayName: "Image"
    },
    canonical: {
      type: "string",
      displayName: "Canonical URL"
    }
  }
};

var _excluded$1 = ["PlasmicIconType"];
function PlasmicIcon(props) {
  var PlasmicIconType = props.PlasmicIconType,
    rest = _objectWithoutPropertiesLoose(props, _excluded$1);
  return createElement(PlasmicIconType, Object.assign({}, rest));
}

var _excluded$2 = ["src", "className", "displayWidth", "displayHeight", "displayMinWidth", "displayMinHeight", "displayMaxWidth", "displayMaxHeight", "quality", "loader", "imgRef", "style", "loading"];
// Default image sizes to snap to
// TODO: make this configurable?
var IMG_SIZES = [16, 32, 48, 64, 96, 128, 256, 384];
var DEVICE_SIZES = [640, 750, 828, 1080, 1200, 1920, 2048, 3840];
var ALL_SIZES = /*#__PURE__*/[].concat(IMG_SIZES, DEVICE_SIZES);
var PlasmicImg = /*#__PURE__*/React__default.forwardRef(function PlasmicImg(props, outerRef) {
  var src = props.src,
    className = props.className,
    displayWidth = props.displayWidth,
    displayHeight = props.displayHeight,
    displayMinWidth = props.displayMinWidth,
    displayMinHeight = props.displayMinHeight,
    displayMaxWidth = props.displayMaxWidth,
    displayMaxHeight = props.displayMaxHeight,
    quality = props.quality,
    loader = props.loader,
    imgRef = props.imgRef,
    style = props.style,
    loading = props.loading,
    rest = _objectWithoutPropertiesLoose(props, _excluded$2);
  var imgProps = Object.assign({}, rest, {
    // Default loading to "lazy" if not specified (which is different from the
    // html img, which defaults to eager!)
    loading: loading != null ? loading : "lazy"
  });
  var _ref = typeof src === "string" || !src ? {
      fullWidth: undefined,
      fullHeight: undefined,
      aspectRatio: undefined
    } : src,
    fullWidth = _ref.fullWidth,
    fullHeight = _ref.fullHeight,
    aspectRatio = _ref.aspectRatio;
  var srcStr = src ? typeof src === "string" ? src : typeof src.src === "string" ? src.src : src.src.src : "";
  // Assume external image if either dimension is null and use usual <img>
  if (fullHeight == null || fullWidth == null) {
    return React__default.createElement("img", Object.assign({
      src: srcStr,
      className: className,
      style: style
    }, imgProps, {
      loading: loading,
      ref: mergeRefs(imgRef, outerRef)
    }));
  }
  if (isSvg(srcStr) && (displayHeight == null || displayHeight === "auto") && (displayWidth == null || displayWidth === "auto")) {
    displayWidth = "100%";
  }
  var computedDisplayWidth = displayWidth;
  if (fullWidth && fullHeight && (!displayWidth || displayWidth === "auto") && !!getPixelLength(displayHeight)) {
    // If there's a pixel length specified for displayHeight but not displayWidth,
    // then we can derive the pixel length for displayWidth.  Having an explicit
    // displayWidth makes this a fixed-size image, which makes it possible for us to
    // generate better markup!
    if (!isSvg(srcStr)) {
      // We shouldn't do it for SVGs though, because `fullWidth` and
      // `fullHeight` might have rounded values so the final
      // `displayWidth` could differ by 1px or so.
      computedDisplayWidth = getPixelLength(displayHeight) * fullWidth / fullHeight;
    }
  }
  var spacerWidth = fullWidth;
  var spacerHeight = fullHeight;
  if (aspectRatio && isFinite(aspectRatio) && isSvg(srcStr)) {
    // For SVGs, fullWidth and fullHeight can be rounded values, which would
    // cause some discrepancy between the actual aspect ratio and the aspect
    // ratio from those values. So, for those cases, we set large width / height
    // values to get a more precise ratio from the spacer.
    spacerWidth = DEFAULT_SVG_WIDTH;
    spacerHeight = Math.round(spacerWidth / aspectRatio);
  }
  var _getWidths = getWidths(computedDisplayWidth, fullWidth, {
      minWidth: displayMinWidth
    }),
    sizes = _getWidths.sizes,
    widthDescs = _getWidths.widthDescs;
  var imageLoader = getImageLoader(loader);
  var spacerSvg = "<svg width=\"" + spacerWidth + "\" height=\"" + spacerHeight + "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>";
  var spacerSvgBase64 = typeof window === "undefined" ? Buffer.from(spacerSvg).toString("base64") : window.btoa(spacerSvg);
  var wrapperStyle = _extends({}, style || {});
  var spacerStyle = _extends({}, pick(style || {}, "objectFit", "objectPosition"));
  if (displayWidth != null && displayWidth !== "auto") {
    // If width is set, set it on the wrapper along with min/max width
    // and just use `width: 100%` on the spacer
    spacerStyle.width = "100%";
    // Rely on the styles set by `classname` on the wrapper:
    // wrapperStyle.width = displayWidth;
    // wrapperStyle.minWidth = displayMinWidth;
    // wrapperStyle.maxWidth = displayMaxWidth;
  } else {
    // Otherwise, we want auto sizing from the spacer, so set width there.
    //
    // But if we have min/max width, it should be set in the wrapper and it
    // can be percentage values (and we add corresponding min/max width to
    // 100% in the spacer). In general it ends up with the correct effect,
    // but some edge cases might make `min-width: 100%` shrink the image more
    // than it should.
    spacerStyle.width = displayWidth;
    wrapperStyle.width = "auto";
    if (displayMinWidth) {
      spacerStyle.minWidth = "100%";
      // Rely on min-width set by `classname` on the wrapper:
      // wrapperStyle.minWidth = displayMinWidth;
    }

    if (displayMaxWidth != null && displayMaxWidth !== "none") {
      spacerStyle.maxWidth = "100%";
      // Rely on max-width set by `classname` on the wrapper:
      // wrapperStyle.maxWidth = displayMaxWidth;
    }
  }

  if (displayHeight != null && displayHeight !== "auto") {
    spacerStyle.height = "100%";
    // wrapperStyle.height = displayHeight;
    // wrapperStyle.minHeight = displayMinHeight;
    // wrapperStyle.maxHeight = displayMaxHeight;
  } else {
    spacerStyle.height = displayHeight;
    wrapperStyle.height = "auto";
    if (displayMinHeight) {
      spacerStyle.minHeight = "100%";
      // wrapperStyle.minHeight = displayMinHeight;
    }

    if (displayMaxHeight != null && displayMaxHeight !== "none") {
      spacerStyle.maxHeight = "100%";
      // wrapperStyle.maxHeight = displayMaxHeight;
    }
  }

  return React__default.createElement("div", {
    className: classNames$1(className, "__wab_img-wrapper"),
    ref: outerRef,
    style: wrapperStyle
  }, React__default.createElement("img", {
    alt: "",
    "aria-hidden": true,
    className: "__wab_img-spacer-svg",
    src: "data:image/svg+xml;base64," + spacerSvgBase64,
    style: spacerStyle
  }), makePicture({
    imageLoader: imageLoader,
    widthDescs: widthDescs,
    sizes: sizes,
    src: srcStr,
    quality: quality,
    ref: imgRef,
    style: style ? pick(style, "objectFit", "objectPosition") : undefined,
    imgProps: imgProps,
    className: "__wab_img"
  }));
});
function makePicture(opts) {
  // If imageLoader is undefined, then this renders to just a normal
  // <img />.  Else it will render to a <picture> with a <source> for
  // webp, and srcSet/sizes set according to width requirements.
  var imageLoader = opts.imageLoader,
    widthDescs = opts.widthDescs,
    src = opts.src,
    quality = opts.quality,
    style = opts.style,
    className = opts.className,
    sizes = opts.sizes,
    imgProps = opts.imgProps,
    ref = opts.ref;
  return React__default.createElement("picture", {
    className: "__wab_picture"
  }, imageLoader && imageLoader.supportsUrl(src) && React__default.createElement("source", {
    type: "image/webp",
    srcSet: widthDescs.map(function (wd) {
      return imageLoader.transformUrl({
        src: src,
        quality: quality,
        width: wd.width,
        format: "webp"
      }) + " " + wd.desc;
    }).join(", ")
  }), React__default.createElement("img", Object.assign({}, imgProps, {
    ref: ref,
    className: className,
    decoding: "async",
    src: imageLoader && imageLoader.supportsUrl(src) ? imageLoader.transformUrl({
      src: src,
      quality: quality,
      width: widthDescs[widthDescs.length - 1].width
    }) : src,
    srcSet: imageLoader && imageLoader.supportsUrl(src) ? widthDescs.map(function (wd) {
      return imageLoader.transformUrl({
        src: src,
        quality: quality,
        width: wd.width
      }) + " " + wd.desc;
    }).join(", ") : undefined,
    sizes: imageLoader && imageLoader.supportsUrl(src) ? sizes : undefined,
    style: _extends({}, style ? pick(style, "objectFit", "objectPosition") : {}, {
      width: 0,
      height: 0
    })
  })));
}
var DEFAULT_SVG_WIDTH = 10000;
function isSvg(src) {
  return src.endsWith(".svg") || src.startsWith("data:image/svg");
}
function getClosestPresetSize(width, fullWidth) {
  var _ALL_SIZES$findIndex;
  var nextBiggerIndex = (_ALL_SIZES$findIndex = ALL_SIZES.findIndex(function (w) {
    return w >= width;
  })) != null ? _ALL_SIZES$findIndex : ALL_SIZES.length - 1;
  var nextBigger = ALL_SIZES[nextBiggerIndex];
  if (nextBigger >= fullWidth) {
    // If the requested width is larger than the fullWidth,
    // we just use the original width instead. It's impossible
    // to make an image bigger than fullWidth!
    return undefined;
  } else if (nextBiggerIndex + 1 < ALL_SIZES.length && fullWidth <= ALL_SIZES[nextBiggerIndex + 1]) {
    // If the fullWidth is just between nextBigger and the one after that,
    // then also might as well just use the original size (so, width is 30,
    // nextBigger is 32, then we just use the original as long as fullWidth is
    // less than 48)
    return undefined;
  }
  return nextBigger;
}
/**
 * Computes the appropriate srcSet and sizes to use
 */
function getWidths(width, fullWidth, extra) {
  var minWidth = extra == null ? void 0 : extra.minWidth;
  var pixelWidth = getPixelLength(width);
  var pixelMinWidth = getPixelLength(minWidth);
  if (pixelWidth != null && (!minWidth || pixelMinWidth != null)) {
    // If there's an exact width, then we just need to display it at 1x and 2x density
    return {
      widthDescs: [{
        width: getClosestPresetSize(Math.max(pixelWidth, pixelMinWidth != null ? pixelMinWidth : 0), fullWidth),
        desc: "1x"
      }, {
        width: getClosestPresetSize(Math.max(pixelWidth, pixelMinWidth != null ? pixelMinWidth : 0) * 2, fullWidth),
        desc: "2x"
      }],
      sizes: undefined
    };
  }
  // Otherwise we don't know what sizes we'll end up, so we just cap it at
  // device width.  TODO: do better!
  var usefulSizes = DEVICE_SIZES.filter(function (size) {
    return !fullWidth || size < fullWidth;
  });
  if (!!fullWidth && usefulSizes.length === 0) {
    // image fullWidth is smaller than all device sizes.  So all we can do
    // is offer 1x
    return {
      widthDescs: [{
        width: getClosestPresetSize(fullWidth, fullWidth),
        desc: "1x"
      }],
      sizes: undefined
    };
  }
  return {
    widthDescs: usefulSizes.map(function (size) {
      return {
        width: getClosestPresetSize(size, fullWidth),
        // If this is the last (buggest) useful width, but it is
        // still within the bounds set by DEVICE_SIZES, then just
        // use the original, unresized image.  This means if we match
        // the largest size, we use unresized and best quality image.
        // We only do this, though, if fullWidth is "reasonable" --
        // smaller than the largest size we would consider.
        // i === usefulSizes.length - 1 &&
        // fullWidth < DEVICE_SIZES[DEVICE_SIZES.length - 1]
        //   ? undefined
        //   : size,
        desc: size + "w"
      };
    }),
    sizes: "100vw"
  };
}
function getPixelLength(length) {
  if (length == null || length == "") {
    return undefined;
  }
  if (typeof length === "number") {
    return length;
  }
  var parsed = parseNumeric(length);
  if (parsed && (!parsed.units || parsed.units === "px")) {
    return parsed.num;
  }
  return undefined;
}
function parseNumeric(val) {
  // Parse strings like "30", "30px", "30%", "30px /* blah blah */"
  var res = val.match(/^\s*(-?(?:\d+\.\d*|\d*\.\d+|\d+))\s*([a-z]*|%)\s*(?:\/\*.*)?$/i);
  if (res == null) {
    return undefined;
  }
  var num = res[1];
  var units = res[2];
  return {
    num: +num,
    units: units
  };
}
function getImageLoader(loader) {
  if (loader == null) {
    return undefined;
  } else if (loader === "plasmic") {
    return PLASMIC_IMAGE_LOADER;
  } else {
    return loader;
  }
}
var PLASMIC_IMAGE_LOADER = {
  supportsUrl: function supportsUrl(src) {
    return src.startsWith("https://img.plasmic.app") && !isSvg(src);
  },
  transformUrl: function transformUrl(opts) {
    var _opts$quality;
    var params = [opts.width ? "w=" + opts.width : undefined, "q=" + ((_opts$quality = opts.quality) != null ? _opts$quality : 75), opts.format ? "f=" + opts.format : undefined].filter(function (x) {
      return !!x;
    });
    return opts.src + "?" + params.join("&");
  }
};

var PlasmicLink = /*#__PURE__*/React__default.forwardRef(function PlasmicLink(props, ref) {
  // props.href is required for nextjs; if no props.href,
  // then we just render the default anchor element
  if (props.platform === "nextjs" && props.href) {
    var nextjsProps = ["href", "replace", "scroll", "shallow", "passHref", "prefetch", "locale"];
    return React__default.createElement(props.component, _extends({}, pick.apply(void 0, [props].concat(nextjsProps)), {
      legacyBehavior: true
    }), React__default.createElement("a", Object.assign({}, omit.apply(void 0, [props, "component", "platform"].concat(nextjsProps)), {
      ref: ref
    })));
  }
  if (props.platform === "gatsby" && isInternalHref(props.href)) {
    return React__default.createElement(props.component, _extends({}, omit(props, "component", "platform", "href"), {
      to: props.href,
      ref: ref
    }));
  }
  return React__default.createElement("a", Object.assign({}, omit(props, "component", "platform"), {
    ref: ref
  }));
});
function isInternalHref(href) {
  return /^\/(?!\/)/.test(href);
}

var PlasmicTranslatorContext = /*#__PURE__*/React__default.createContext(undefined);
function isIterable(val) {
  return val != null && typeof val[Symbol.iterator] === "function";
}
function genTranslatableString(elt) {
  var components = {};
  var componentsCount = 0;
  var getText = function getText(node) {
    if (!node) {
      return "";
    }
    if (typeof node === "number" || typeof node === "boolean" || typeof node === "string") {
      return node.toString();
    }
    if (typeof node !== "object") {
      return "";
    }
    if (Array.isArray(node) || isIterable(node)) {
      return Array.from(node).map(function (child) {
        return getText(child);
      }).filter(function (child) {
        return !!child;
      }).join("");
    }
    var nodeChildren = hasKey(node, "props") && hasKey(node.props, "children") && node.props.children || hasKey(node, "children") && node.children || [];
    var contents = "" + React__default.Children.toArray(nodeChildren).map(function (child) {
      return getText(child);
    }).filter(function (child) {
      return !!child;
    }).join("");
    if (React__default.isValidElement(node) && node.type === React__default.Fragment) {
      return contents;
    }
    var componentId = componentsCount + 1;
    componentsCount++;
    components[componentId] = React__default.isValidElement(node) ? React__default.cloneElement(node, {
      key: componentId,
      children: undefined
    }) : node;
    return "<" + componentId + ">" + contents + "</" + componentId + ">";
  };
  var str = getText(elt);
  return {
    str: str,
    components: components,
    componentsCount: componentsCount
  };
}
function Trans(_ref) {
  var transKey = _ref.transKey,
    children = _ref.children;
  var _t = React__default.useContext(PlasmicTranslatorContext);
  if (!_t) {
    warnNoTranslationFunctionAtMostOnce();
    return children;
  }
  var _genTranslatableStrin = genTranslatableString(children),
    str = _genTranslatableStrin.str,
    components = _genTranslatableStrin.components,
    componentsCount = _genTranslatableStrin.componentsCount;
  return _t(transKey != null ? transKey : str, componentsCount > 0 ? {
    components: components
  } : undefined);
}
var hasWarned = false;
function warnNoTranslationFunctionAtMostOnce() {
  if (!hasWarned) {
    console.warn("Using Plasmic Translation but no translation function has been provided");
    hasWarned = true;
  }
}
function hasKey(v, key) {
  return typeof v === "object" && v !== null && key in v;
}

var _excluded$3 = ["as", "defaultContents", "value"];
function PlasmicSlot(props) {
  return renderPlasmicSlot(props);
}
function renderPlasmicSlot(opts) {
  var as = opts.as,
    defaultContents = opts.defaultContents,
    value = opts.value,
    rest = _objectWithoutPropertiesLoose(opts, _excluded$3);
  var content = value === undefined ? defaultContents : value;
  if (!content || Array.isArray(content) && content.length === 0) {
    return null;
  }
  // If the content is a raw string, then we need to wrap the raw string
  // into an element, in case the slot is inside a flex-gap
  // container (you cannot apply margin to just a text node).
  var maybeString = maybeAsString(content);
  if (maybeString) {
    content = createElement("span", {
      className: "__wab_slot-string-wrapper"
    }, maybeString);
  }
  var nonEmptyProps = Object.keys(rest).filter(function (p) {
    return !!rest[p];
  });
  if (nonEmptyProps.length === 0) {
    // No attrs to apply to the slot (which means the slot is unstyled), then
    // just render the content directly; no need for style wrapper.
    return createElement(Fragment, null, content);
  }
  return createElement(as || "span", mergeProps({
    className: "__wab_slot"
  }, rest), content);
}
function maybeAsString(node) {
  // Unwrap fragments
  if (isValidElement(node)) {
    // Fragment doesn't render DOM elements
    if (node.type === Fragment) {
      return maybeAsString(node.props.children);
    } else if (node.type === Trans) {
      // Trans also doesn't render DOM elements. But we don't want to just render
      // its content string, because we want to keep the <Trans/> for the localization.
      // So we render the same node, to be wrapped into __wab_slot-string-wrapper.
      return node;
    }
  }
  if (typeof node === "string") {
    return node;
  }
  if (Array.isArray(node) && node.length === 1 && typeof node[0] === "string") {
    return node[0];
  }
  return undefined;
}

var listeners = [];
var queries = {};
function matchScreenVariants() {
  if (!isBrowser) {
    return [];
  }
  return Object.entries(queries).filter(function (_ref) {
    var query = _ref[1];
    return window.matchMedia(query).matches;
  }).map(function (_ref2) {
    var name = _ref2[0];
    return name;
  });
}
// undefined if screen variants have never been calculated
var curScreenVariants = undefined;
function recalculateScreenVariants() {
  var screenVariant = matchScreenVariants();
  if (!curScreenVariants || screenVariant.join("") !== curScreenVariants.join("")) {
    curScreenVariants = screenVariant;
    ReactDOM__default.unstable_batchedUpdates(function () {
      return listeners.forEach(function (listener) {
        return listener();
      });
    });
  }
}
function ensureInitCurScreenVariants() {
  // Initializes curScreenVariants if it hadn't been before. Note that this must
  // be called from within an effect.
  if (curScreenVariants === undefined) {
    curScreenVariants = matchScreenVariants();
  }
}
if (isBrowser) {
  window.addEventListener("resize", recalculateScreenVariants);
}
function createUseScreenVariants(isMulti, screenQueries) {
  Object.assign(queries, screenQueries);
  curScreenVariants = undefined;
  return function () {
    // It is important that upon first render, we return [] or undefined, because
    // that is what SSR will use, and the client must match.  In an effect (which
    // only happens on the client), we then actually ask for the real screen variant
    // and, if different from [] or undefined, forces a re-render.
    var _React$useState = useState(),
      updateState = _React$useState[1];
    var lastScreenVariantsRef = useRef(curScreenVariants || []);
    // We do useLayoutEffect instead of useEffect to immediately
    // register our forceUpdate. This ensures that if there was
    // a window resize event between render and effects, that the
    // listener will be registered in time
    useIsomorphicLayoutEffect(function () {
      var updateIfChanged = function updateIfChanged() {
        if (curScreenVariants && lastScreenVariantsRef.current.join("") !== curScreenVariants.join("")) {
          lastScreenVariantsRef.current = curScreenVariants;
          // Force update
          updateState({});
        }
      };
      // Listeners are invoked whenever the window is resized
      listeners.push(updateIfChanged);
      // Initialize the curScreenVariants for the first time.  We don't need
      // to invoke the listeners here because all components will already
      // have this effect running and will re-render if the real screen
      // variant is non-empty.
      ensureInitCurScreenVariants();
      // Now, if the curScreenVariants differs from what we returned last,
      // then force a re-render.
      updateIfChanged();
      return function () {
        // Remove our listener on unmount
        listeners.splice(listeners.indexOf(updateIfChanged), 1);
      };
    }, []);
    if (isMulti) {
      return curScreenVariants || [];
    } else if (curScreenVariants) {
      return curScreenVariants[curScreenVariants.length - 1];
    } else {
      return undefined;
    }
  };
}

var PlasmicRootContext = /*#__PURE__*/createContext(undefined);
function PlasmicRootProvider(props) {
  var platform = props.platform,
    children = props.children,
    userAuthToken = props.userAuthToken,
    isUserLoading = props.isUserLoading,
    authRedirectUri = props.authRedirectUri,
    user = props.user;
  var context = useMemo(function () {
    return {
      platform: platform
    };
  }, [platform]);
  var dataSourceContextValue = useMemo(function () {
    return {
      userAuthToken: userAuthToken,
      user: user,
      isUserLoading: isUserLoading,
      authRedirectUri: authRedirectUri
    };
  }, [userAuthToken, isUserLoading, user, authRedirectUri]);
  return createElement(PlasmicRootContext.Provider, {
    value: context
  }, createElement(SSRProvider, null, createElement(PlasmicDataSourceContextProvider, {
    value: dataSourceContextValue
  }, createElement(PlasmicTranslatorContext.Provider, {
    value: props.translator
  }, createElement(PlasmicHeadContext.Provider, {
    value: props.Head
  }, children)))));
}
var useIsSSR = useIsSSR$1;
function useHasPlasmicRoot() {
  return !!useContext(PlasmicRootContext);
}
var hasWarnedSSR = false;
/**
 * Warns the user if PlasmicRootProvider is not used
 */
function useEnsureSSRProvider() {
  var hasRoot = useHasPlasmicRoot();
  if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== "development") {
    return;
  }
  hasWarnedSSR = true;
  console.warn("Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr");
}

function useFocused(opts) {
  var _useAriaFocusRing = useFocusRing({
      within: false,
      isTextInput: opts.isTextInput
    }),
    isFocused = _useAriaFocusRing.isFocused,
    focusProps = _useAriaFocusRing.focusProps;
  return [isFocused, focusProps];
}
function useFocusVisible(opts) {
  var _useAriaFocusRing2 = useFocusRing({
      within: false,
      isTextInput: opts.isTextInput
    }),
    isFocusVisible = _useAriaFocusRing2.isFocusVisible,
    focusProps = _useAriaFocusRing2.focusProps;
  return [isFocusVisible, focusProps];
}
function useFocusedWithin(opts) {
  var _useAriaFocusRing3 = useFocusRing({
      within: true,
      isTextInput: opts.isTextInput
    }),
    isFocused = _useAriaFocusRing3.isFocused,
    focusProps = _useAriaFocusRing3.focusProps;
  return [isFocused, focusProps];
}
function useFocusVisibleWithin(opts) {
  var _useAriaFocusRing4 = useFocusRing({
      within: true,
      isTextInput: opts.isTextInput
    }),
    isFocusVisible = _useAriaFocusRing4.isFocusVisible,
    focusProps = _useAriaFocusRing4.focusProps;
  return [isFocusVisible, focusProps];
}
function useHover() {
  var _React$useState = useState(false),
    isHover = _React$useState[0],
    setHover = _React$useState[1];
  return [isHover, {
    onMouseEnter: function onMouseEnter() {
      return setHover(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setHover(false);
    }
  }];
}
function usePressed() {
  var _React$useState2 = useState(false),
    isPressed = _React$useState2[0],
    setPressed = _React$useState2[1];
  return [isPressed, {
    onMouseDown: function onMouseDown() {
      return setPressed(true);
    },
    onMouseUp: function onMouseUp() {
      return setPressed(false);
    }
  }];
}
var TRIGGER_TO_HOOK = {
  useHover: useHover,
  useFocused: useFocused,
  useFocusVisible: useFocusVisible,
  useFocusedWithin: useFocusedWithin,
  useFocusVisibleWithin: useFocusVisibleWithin,
  usePressed: usePressed
};
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */
function useTrigger(trigger, opts) {
  return TRIGGER_TO_HOOK[trigger](opts);
}

var ARRAY_SYMBOL = /*#__PURE__*/Symbol("[]");
var PLASMIC_STATE_PROXY_SYMBOL = /*#__PURE__*/Symbol("plasmic.state.proxy");

var UNINITIALIZED = /*#__PURE__*/Symbol("plasmic.unitialized");
var StateSpecNode = /*#__PURE__*/function () {
  function StateSpecNode(specs) {
    this._specs = specs;
    this._edges = new Map();
    this._state = {};
  }
  var _proto = StateSpecNode.prototype;
  _proto.setSpecs = function setSpecs(specs) {
    this._specs = specs;
  };
  _proto.edges = function edges() {
    return this._edges;
  };
  _proto.state = function state() {
    return this._state;
  };
  _proto.hasEdge = function hasEdge(key) {
    return this._edges.has(key);
  };
  _proto.addEdge = function addEdge(key, node) {
    this._edges.set(key, node);
  };
  _proto.clearEdges = function clearEdges() {
    this._edges = new Map();
  };
  _proto.children = function children() {
    return this._edges.values();
  };
  _proto.makeTransition = function makeTransition(key) {
    key = isNum(key) ? ARRAY_SYMBOL : key;
    return this._edges.get(key);
  };
  _proto.isLeaf = function isLeaf() {
    return this._edges.size === 0;
  };
  _proto.hasArrayTransition = function hasArrayTransition() {
    return this._edges.has(ARRAY_SYMBOL);
  };
  _proto.getSpec = function getSpec() {
    return this._specs[0];
  };
  _proto.getAllSpecs = function getAllSpecs() {
    return this._specs;
  };
  _proto.getState = function getState(path) {
    return this._state[JSON.stringify(path)];
  };
  _proto.getInitFunc = function getInitFunc(stateCell) {
    var _stateCell$registered;
    return (_stateCell$registered = stateCell.registeredInitFunc) != null ? _stateCell$registered : this.getSpec().initFunc;
  };
  _proto.clearStates = function clearStates() {
    this._state = {};
  };
  _proto.states = function states() {
    return Object.values(this._state);
  };
  _proto.hasState = function hasState(path) {
    var key = JSON.stringify(path);
    return key in this._state;
  };
  _proto.createStateCell = function createStateCell(path) {
    var key = JSON.stringify(path);
    this._state[key] = {
      listeners: [],
      initialValue: UNINITIALIZED,
      path: path
    };
  };
  _proto.deleteStateCell = function deleteStateCell(prefixPath) {
    var _this = this;
    [].concat(Object.keys(this._state)).forEach(function (key) {
      var path = JSON.parse(key);
      if (shallowEqual(prefixPath, path.slice(0, prefixPath.length))) {
        delete _this._state[key];
      }
    });
  };
  _proto.setInitialValue = function setInitialValue(path, value) {
    var key = JSON.stringify(path);
    this._state[key].initialValue = value;
  };
  _proto.getInitialValue = function getInitialValue(path) {
    var key = JSON.stringify(path);
    return this._state[key].initialValue;
  };
  _proto.addListener = function addListener(path, f) {
    var key = JSON.stringify(path);
    this._state[key].listeners.push(f);
  };
  return StateSpecNode;
}();
var transformPathStringToObj = function transformPathStringToObj(str) {
  var splitStatePathPart = function splitStatePathPart(state) {
    return state.endsWith("[]") ? [].concat(splitStatePathPart(state.slice(0, -2)), [ARRAY_SYMBOL]) : [state];
  };
  return str.split(".").flatMap(splitStatePathPart);
};
function buildTree(specs) {
  var internalSpec = specs.map(function (spec) {
    return _extends({}, spec, {
      pathObj: transformPathStringToObj(spec.path),
      isRepeated: spec.path.split(".").some(function (part) {
        return part.endsWith("[]");
      })
    });
  });
  var rec = function rec(currentPath) {
    var node = new StateSpecNode(internalSpec.filter(function (spec) {
      return shallowEqual(currentPath, spec.pathObj.slice(0, currentPath.length));
    }));
    node.getAllSpecs().forEach(function (spec) {
      if (spec.pathObj.length > currentPath.length) {
        var nextKey = spec.pathObj[currentPath.length];
        if (!node.hasEdge(nextKey)) {
          node.addEdge(nextKey, rec([].concat(currentPath, [nextKey])));
        }
      }
    });
    return node;
  };
  return rec([]);
}
function updateTree(root, specs) {
  var internalSpec = specs.map(function (spec) {
    return _extends({}, spec, {
      pathObj: transformPathStringToObj(spec.path),
      isRepeated: spec.path.split(".").some(function (part) {
        return part.endsWith("[]");
      })
    });
  });
  var rec = function rec(oldNode, currentPath) {
    var nodeSpecs = internalSpec.filter(function (spec) {
      return shallowEqual(currentPath, spec.pathObj.slice(0, currentPath.length));
    });
    var node = oldNode != null ? oldNode : new StateSpecNode(nodeSpecs);
    node.setSpecs(nodeSpecs);
    var oldEdges = oldNode == null ? void 0 : oldNode.edges();
    node.clearEdges();
    node.getAllSpecs().forEach(function (spec) {
      if (spec.pathObj.length > currentPath.length) {
        var nextKey = spec.pathObj[currentPath.length];
        if (!node.hasEdge(nextKey)) {
          node.addEdge(nextKey, rec(oldEdges == null ? void 0 : oldEdges.get(nextKey), [].concat(currentPath, [nextKey])));
        }
      }
    });
    return node;
  };
  return rec(root, []);
}
function getStateCells(root) {
  var leaves = [];
  var rec = function rec(node) {
    for (var _iterator = _createForOfIteratorHelperLoose(node.children()), _step; !(_step = _iterator()).done;) {
      var child = _step.value;
      rec(child);
    }
    if (node.isLeaf() && node.getAllSpecs().length > 0) {
      leaves.push(node);
    }
  };
  rec(root);
  return leaves;
}
function findStateCell(root, pathStr, repetitionIndex) {
  var realPath = [];
  var pathObj = transformPathStringToObj(pathStr);
  var currRepIndex = 0;
  for (var _iterator2 = _createForOfIteratorHelperLoose(pathObj), _step2; !(_step2 = _iterator2()).done;) {
    var part = _step2.value;
    if (typeof part === "symbol") {
      if (!root.hasArrayTransition() || !repetitionIndex || currRepIndex > repetitionIndex.length) {
        throw new Error("transition not found: pathStr " + pathStr + " part " + (typeof part === "symbol" ? "[]" : part));
      }
      realPath.push(repetitionIndex[currRepIndex++]);
      root = root.makeTransition(ARRAY_SYMBOL);
    } else {
      if (!root.hasEdge(part)) {
        throw new Error("transition not found: pathStr " + pathStr + " part " + (typeof part === "symbol" ? "[]" : part));
      }
      realPath.push(part);
      root = root.makeTransition(part);
    }
  }
  return {
    node: root,
    realPath: realPath
  };
}

function generateStateOnChangeProp($state, path) {
  return function (val) {
    return set($state, path, val);
  };
}
function generateStateValueProp($state, path) {
  return _get($state, path);
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? useLayoutEffect : useEffect;
function isPlasmicStateProxy(obj) {
  return obj != null && typeof obj === "object" && !!obj[PLASMIC_STATE_PROXY_SYMBOL];
}
function getStateCellsInPlasmicProxy(obj) {
  if (!isPlasmicStateProxy(obj)) {
    return [];
  }
  var _obj$PLASMIC_STATE_PR = obj[PLASMIC_STATE_PROXY_SYMBOL],
    rootNode = _obj$PLASMIC_STATE_PR.node,
    rootPath = _obj$PLASMIC_STATE_PR.path,
    isOutside = _obj$PLASMIC_STATE_PR.isOutside;
  if (isOutside) {
    return [];
  }
  return getStateCells(rootNode).flatMap(function (node) {
    return node.states().map(function (stateCell) {
      return {
        path: node.getSpec().path,
        realPath: stateCell.path.slice(rootPath.length)
      };
    });
  });
}
function getStateSpecInPlasmicProxy(obj, path) {
  obj = _get(obj, path.slice(0, path.length - 1));
  if (!isPlasmicStateProxy(obj)) {
    return undefined;
  }
  var _obj$PLASMIC_STATE_PR2 = obj[PLASMIC_STATE_PROXY_SYMBOL],
    node = _obj$PLASMIC_STATE_PR2.node,
    isOutside = _obj$PLASMIC_STATE_PR2.isOutside;
  var nextNode = node.makeTransition(path[path.length - 1]);
  if (isOutside || node.isLeaf() || !nextNode) {
    return undefined;
  }
  return {
    spec: nextNode.getSpec(),
    isImplicitStateArray: nextNode.hasArrayTransition()
  };
}
function shallowEqual(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (var i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
/**
 * Shallow comparison of arrays.
 */
function arrayEq(xs, ys) {
  return xs.length === ys.length && xs.every(function (_, index) {
    return xs[index] === ys[index];
  });
}
function isNum(value) {
  return typeof value === "symbol" ? false : !isNaN(+value);
}
function assert(cond, msg) {
  if (msg === void 0) {
    msg = "Assertion failed";
  }
  if (!cond) {
    // We always generate an non empty message so that it doesn't get swallowed
    // by the async library.
    msg = (typeof msg === "string" ? msg : msg()) || "Assertion failed";
    debugger;
    throw new Error(msg);
  }
}
/**
 * Forked from https://github.com/lukeed/dset
 * Changes: fixed setting a deep value to a proxy object
 */
function set(obj, keys, val) {
  keys = keys.split ? keys.split(".") : keys;
  var i = 0,
    l = keys.length,
    t = obj,
    x,
    k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype") break;
    var newValue = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
    assignValue(t, k, newValue);
    t = t[k];
  }
}
/**
 * Forked from lodash
 */
function baseAssignValue(object, key, value) {
  if (key == "__proto__") {
    Object.defineProperty(object, key, {
      configurable: true,
      enumerable: true,
      value: value,
      writable: true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(Object.prototype.hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

function isNum$1(value) {
  return typeof value === "symbol" ? false : !isNaN(+value);
}
function canProxy(value) {
  return typeof value === "object" && value != null;
}
function initializeStateValue($$state, initialSpecNode, initialStatePath, proxyRoot) {
  var stateAccess = new Set();
  var $state = create$StateProxy($$state, function (node, path) {
    return {
      get: function get() {
        stateAccess.add({
          path: path,
          node: node
        });
        var spec = node.getSpec();
        if (spec.valueProp) {
          return $$state.env.$props[spec.valueProp];
        } else if (!node.hasState(path) && spec.initFunc) {
          node.createStateCell(path);
          return initializeStateValue($$state, node, path, proxyRoot);
        }
        return _get(proxyRoot, path);
      },
      set: function set() {
        throw new Error("Cannot update state values during initialization");
      }
    };
  });
  stateAccess.forEach(function (_ref) {
    var node = _ref.node,
      path = _ref.path;
    node.addListener(path, function () {
      var newValue = invokeInitFuncBackwardsCompatible(initialSpecNode.getSpec().initFunc, _extends({
        $state: $state
      }, $$state.env));
      set(proxyRoot, initialStatePath, newValue);
    });
  });
  var initFunc = initialSpecNode.getInitFunc(initialSpecNode.getState(initialStatePath));
  var initialValue = invokeInitFuncBackwardsCompatible(initFunc, _extends({
    $state: $state
  }, $$state.env));
  initialSpecNode.setInitialValue(initialStatePath, clone(initialValue));
  var initialSpec = initialSpecNode.getSpec();
  var value = initialSpec.isImmutable ? mkUntrackedValue(initialValue) : clone(initialValue);
  set(proxyRoot, initialStatePath, value);
  //immediately fire onChange
  if (initialSpec.onChangeProp) {
    var _$$state$env$$props$i, _$$state$env$$props;
    (_$$state$env$$props$i = (_$$state$env$$props = $$state.env.$props)[initialSpec.onChangeProp]) == null ? void 0 : _$$state$env$$props$i.call(_$$state$env$$props, initialValue);
  }
  return initialValue;
}
function create$StateProxy($$state, leafHandlers) {
  var proxyRoot;
  var rec = function rec(currPath, currNode, isOutside, initialObject) {
    var getNextPath = function getNextPath(property) {
      return [].concat(currPath, [isNum$1(property) ? +property : property]);
    };
    var spec = currNode.getSpec();
    var handlers = {
      deleteProperty: function deleteProperty(target, property) {
        if (!isOutside && !currNode.isLeaf() && !currNode.hasArrayTransition() && !isNum$1(property)) {
          throw new Error("Can't delete a property in the middle of the state spec");
        }
        delete _get($$state.stateValues, currPath)[property];
        if (spec.onChangeProp) {
          var _$$state$env$$props$s, _$$state$env$$props2;
          //we are always in a leaf, since we only have two cases:
          // 1 - delete properties outside the state tree
          // 2 - delete indices in repeated implicit states, but these can't be exposed, so they don't have onChangeProp
          (_$$state$env$$props$s = (_$$state$env$$props2 = $$state.env.$props)[spec.onChangeProp]) == null ? void 0 : _$$state$env$$props$s.call(_$$state$env$$props2, _get(proxyRoot, currPath.slice(spec.pathObj.length)));
        }
        var nextPath = getNextPath(property);
        var nextNode = currNode.makeTransition(property);
        if (nextNode) {
          getStateCells(nextNode).forEach(function (node) {
            node.deleteStateCell(nextPath);
          });
        }
        return Reflect.deleteProperty(target, property);
      },
      get: function get(target, property, receiver) {
        if (property === PLASMIC_STATE_PROXY_SYMBOL) {
          return {
            node: currNode,
            path: currPath,
            isOutside: isOutside
          };
        }
        var nextPath = getNextPath(property);
        if (isOutside || currNode.isLeaf()) {
          return Reflect.get(target, property, receiver);
        }
        var nextNode = currNode.makeTransition(property);
        if (nextNode != null && nextNode.isLeaf()) {
          var _leafHandlers$get, _leafHandlers;
          return (_leafHandlers$get = (_leafHandlers = leafHandlers(nextNode, nextPath)).get) == null ? void 0 : _leafHandlers$get.call(_leafHandlers, target, property, receiver);
        } else if (nextNode && !(property in target)) {
          target[property] = rec(nextPath, nextNode, false, undefined);
        }
        return Reflect.get(target, property, receiver);
      },
      set: function set$1(target, property, value, receiver) {
        var _nextNode, _nextNode2;
        var nextPath = getNextPath(property);
        var nextNode = currNode.makeTransition(property);
        if (property === "registerInitFunc" && currPath.length === 0) {
          return Reflect.set(target, property, value, receiver);
        }
        if (!nextNode && currNode.hasArrayTransition()) {
          set($$state.stateValues, nextPath, value);
          //array can set his own properties such as length, map, ...
          return Reflect.set(target, property, value, receiver);
        }
        if ((_nextNode = nextNode) != null && _nextNode.isLeaf()) {
          var _leafHandlers$set, _leafHandlers2;
          (_leafHandlers$set = (_leafHandlers2 = leafHandlers(nextNode, nextPath)).set) == null ? void 0 : _leafHandlers$set.call(_leafHandlers2, target, property, value, receiver);
        }
        if (!isOutside && !currNode.isLeaf() && !nextNode) {
          // can't set an unknown field in $state
          return false;
        }
        // we keep pointing to the leaf
        if (!nextNode) {
          assert(isOutside || currNode.isLeaf, "unexpected update in nextNode");
          nextNode = currNode;
        }
        if (canProxy(value)) {
          target[property] = rec(nextPath, nextNode, isOutside || currNode.isLeaf(), value);
        } else if (!isOutside && !currNode.isLeaf() && !((_nextNode2 = nextNode) != null && _nextNode2.isLeaf())) {
          throw new Error("inserting a primitive value into a non-leaf");
        } else {
          Reflect.set(target, property, value, receiver);
        }
        if (currNode.isLeaf()) {
          if (spec.onChangeProp) {
            var _$$state$env$$props$s2, _$$state$env$$props3;
            (_$$state$env$$props$s2 = (_$$state$env$$props3 = $$state.env.$props)[spec.onChangeProp]) == null ? void 0 : _$$state$env$$props$s2.call(_$$state$env$$props3, target);
          }
        } else {
          nextNode.getAllSpecs().forEach(function (spec) {
            if (spec.onChangeProp) {
              var _$$state$env$$props$s3, _$$state$env$$props4;
              (_$$state$env$$props$s3 = (_$$state$env$$props4 = $$state.env.$props)[spec.onChangeProp]) == null ? void 0 : _$$state$env$$props$s3.call(_$$state$env$$props4, value);
            }
          });
        }
        var newValue = (isOutside || currNode.isLeaf()) && currNode.getSpec().isImmutable ? mkUntrackedValue(value) : value;
        set($$state.stateValues, nextPath, newValue);
        return true;
      }
    };
    var baseObject = !isOutside && !currNode.isLeaf() ? currNode.hasArrayTransition() ? [] : {} : Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject != null ? initialObject : {}));
    var proxyObj = new Proxy(baseObject, handlers);
    if (currPath.length === 0) {
      proxyRoot = proxyObj;
    }
    if (initialObject) {
      Reflect.ownKeys(initialObject).forEach(function (key) {
        var desc = Object.getOwnPropertyDescriptor(initialObject, key);
        if (desc.get || desc.set) {
          Object.defineProperty(baseObject, key, desc);
        } else {
          proxyObj[key] = initialObject[key];
        }
      });
    }
    return proxyObj;
  };
  return rec([], $$state.rootSpecTree, false, undefined);
}
var mkUntrackedValue = function mkUntrackedValue(o) {
  return o != null && typeof o === "object" ? ref(o) : o;
};
var envFieldsAreNonNill = function envFieldsAreNonNill(env) {
  var _env$$ctx, _env$$queries;
  return {
    $props: env.$props,
    $ctx: (_env$$ctx = env.$ctx) != null ? _env$$ctx : {},
    $queries: (_env$$queries = env.$queries) != null ? _env$$queries : {}
  };
};
/**
 * We need to support two versions with different parameters to be backward compatible
 *    {
 *       specs: $StateSpec<any>[],
 *       props: Record<string, any>,
 *       $ctx?: Record<string, any>,
 *       opts?: { inCanvas: boolean; }
 *    }
 *    {
 *       specs: $StateSpec<any>[],
 *       env: { $props; $queries; $ctx },
 *       opts?: { inCanvas: boolean }
 *    }
 */
function extractDollarStateParametersBackwardCompatible() {
  if ("$props" in (arguments.length <= 0 ? undefined : arguments[0])) {
    // latest version
    return {
      env: arguments.length <= 0 ? undefined : arguments[0],
      opts: arguments.length <= 1 ? undefined : arguments[1]
    };
  } else {
    return {
      env: {
        $props: arguments.length <= 0 ? undefined : arguments[0],
        $ctx: arguments.length <= 1 ? undefined : arguments[1],
        $queries: {}
      },
      opts: arguments.length <= 2 ? undefined : arguments[2]
    };
  }
}
function invokeInitFuncBackwardsCompatible(initFunc, env) {
  if (initFunc.length > 1) {
    return initFunc(env.$props, env.$state, env.$ctx);
  } else {
    return initFunc(env);
  }
}
function useDollarState(specs) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  var _extractDollarStatePa = extractDollarStateParametersBackwardCompatible.apply(void 0, rest),
    env = _extractDollarStatePa.env,
    opts = _extractDollarStatePa.opts;
  var $$state = React__default.useRef(function () {
    var rootSpecTree = buildTree(specs);
    return {
      rootSpecTree: rootSpecTree,
      specTreeLeaves: getStateCells(rootSpecTree),
      stateValues: proxy({}),
      env: envFieldsAreNonNill(env),
      specs: [],
      registrationsQueue: proxy([])
    };
  }()).current;
  $$state.env = envFieldsAreNonNill(env), $$state.specs = specs;
  var create$State = function create$State() {
    var $state = Object.assign(create$StateProxy($$state, function (node, path) {
      if (!node.hasState(path)) {
        node.createStateCell(path);
        var spec = node.getSpec();
        if (spec.initFunc) {
          initializeStateValue($$state, node, path, $state);
        } else if (!spec.valueProp) {
          set($state, path, spec.initVal);
        }
      }
      return {
        get: function get(target, property, receiver) {
          var spec = node.getSpec();
          if (spec.valueProp) {
            return $$state.env.$props[spec.valueProp];
          } else {
            return Reflect.get(target, property, receiver);
          }
        }
      };
    }), {
      registerInitFunc: function registerInitFunc(pathStr, f, repetitionIndex) {
        var _findStateCell = findStateCell($$state.rootSpecTree, pathStr, repetitionIndex),
          node = _findStateCell.node,
          realPath = _findStateCell.realPath;
        if (!node.hasState(realPath)) {
          node.createStateCell(realPath);
        }
        if (!deepEqual(node.getState(realPath).initialValue, f(_extends({
          $state: $state
        }, $$state.env)))) {
          $$state.registrationsQueue.push(mkUntrackedValue({
            node: node,
            path: realPath,
            f: f
          }));
        }
      }
    });
    return $state;
  };
  var ref = React__default.useRef(undefined);
  if (!ref.current) {
    ref.current = create$State();
  }
  var $state = ref.current;
  if (opts != null && opts.inCanvas) {
    $$state.rootSpecTree = updateTree($$state.rootSpecTree, specs);
    var newLeaves = getStateCells($$state.rootSpecTree);
    if (!arrayEq(newLeaves, $$state.specTreeLeaves)) {
      var old$State = $state;
      $state = ref.current = create$State();
      $$state.specTreeLeaves = newLeaves;
      $$state.specTreeLeaves.flatMap(function (node) {
        return node.states();
      }).forEach(function (_ref2) {
        var path = _ref2.path;
        set($state, path, _get(old$State, path));
      });
    }
    // we need to eager initialize all states in canvas to populate the data picker
    $$state.specTreeLeaves.forEach(function (node) {
      var spec = node.getSpec();
      if (spec.isRepeated || node.hasState(spec.pathObj)) {
        return;
      }
      node.createStateCell(spec.pathObj);
      var init = spec.valueProp ? $$state.env.$props[spec.valueProp] : spec.initFunc ? initializeStateValue($$state, node, spec.pathObj, $state) : spec.initVal;
      set($state, spec.pathObj, init);
    });
  }
  // For each spec with an initFunc, evaluate it and see if
  // the init value has changed. If so, reset its state.
  var resetSpecs = [];
  $$state.specTreeLeaves.flatMap(function (node) {
    return node.states().map(function (stateCell) {
      return {
        stateCell: stateCell,
        node: node
      };
    });
  }).forEach(function (_ref3) {
    var node = _ref3.node,
      stateCell = _ref3.stateCell;
    var initFunc = node.getInitFunc(stateCell);
    if (initFunc) {
      var newInit = invokeInitFuncBackwardsCompatible(initFunc, _extends({
        $state: $state
      }, envFieldsAreNonNill(env)));
      if (!deepEqual(newInit, stateCell.initialValue)) {
        resetSpecs.push({
          stateCell: stateCell,
          node: node
        });
      }
    }
  });
  var reInitializeState = function reInitializeState(node, stateCell) {
    var newInit = initializeStateValue($$state, node, stateCell.path, $state);
    var spec = node.getSpec();
    if (spec.onChangeProp) {
      var _$$state$env$$props$s4, _$$state$env$$props5;
      (_$$state$env$$props$s4 = (_$$state$env$$props5 = $$state.env.$props)[spec.onChangeProp]) == null ? void 0 : _$$state$env$$props$s4.call(_$$state$env$$props5, newInit);
    }
  };
  useIsomorphicLayoutEffect$1(function () {
    resetSpecs.forEach(function (_ref4) {
      var stateCell = _ref4.stateCell,
        node = _ref4.node;
      reInitializeState(node, stateCell);
    });
  }, [env.$props, resetSpecs]);
  useIsomorphicLayoutEffect$1(function () {
    while ($$state.registrationsQueue.length) {
      var _$$state$registration = $$state.registrationsQueue.shift(),
        node = _$$state$registration.node,
        path = _$$state$registration.path,
        f = _$$state$registration.f;
      var stateCell = node.getState(path);
      stateCell.registeredInitFunc = f;
      reInitializeState(node, stateCell);
    }
  }, [$$state.registrationsQueue.length]);
  // immediately initialize exposed non-private states
  useIsomorphicLayoutEffect$1(function () {
    $$state.specTreeLeaves.forEach(function (node) {
      var spec = node.getSpec();
      if (!spec.isRepeated && spec.type !== "private" && spec.initFunc) {
        node.createStateCell(spec.pathObj);
        initializeStateValue($$state, node, spec.pathObj, $state);
      }
    });
  }, []);
  // Re-render if any value changed in one of these objects
  useSnapshot($$state.stateValues, {
    sync: true
  });
  useSnapshot($$state.registrationsQueue);
  return $state;
}

// Utilities used by generated code
var classNames = classNames$1;

var PLUME_STRICT_MODE = true;
function setPlumeStrictMode(mode) {
  PLUME_STRICT_MODE = mode;
}
function mergeVariantToggles() {
  for (var _len = arguments.length, toggles = new Array(_len), _key = 0; _key < _len; _key++) {
    toggles[_key] = arguments[_key];
  }
  var definedToggles = toggles.filter(function (x) {
    return !!x.def;
  });
  var grouped = groupBy(definedToggles, function (_ref) {
    var def = _ref.def;
    return def.group;
  });
  return mapValues(grouped, function (subToggles) {
    return Object.fromEntries(subToggles.map(function (_ref2) {
      var def = _ref2.def,
        active = _ref2.active;
      return [def.variant, !!active];
    }));
  });
}
function noOutline() {
  return {
    outline: "none"
  };
}
function getPlumeType(child) {
  if (!isValidElement(child)) {
    return undefined;
  }
  var childType = child.type;
  return childType.__plumeType || (childType.getPlumeType == null ? void 0 : childType.getPlumeType(child.props));
}

var _excluded$4 = ["link", "isDisabled", "startIcon", "endIcon", "showStartIcon", "showEndIcon", "children"];
function useButton(plasmicClass, props, config, ref) {
  var _ref, _ref2, _extends2, _overrides;
  if (ref === void 0) {
    ref = null;
  }
  var link = props.link,
    isDisabled = props.isDisabled,
    startIcon = props.startIcon,
    endIcon = props.endIcon,
    showStartIcon = props.showStartIcon,
    showEndIcon = props.showEndIcon,
    children = props.children,
    rest = _objectWithoutPropertiesLoose(props, _excluded$4);
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.showStartIconVariant,
    active: showStartIcon
  }, {
    def: config.showEndIconVariant,
    active: showEndIcon
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.startIconSlot && (_ref = {}, _ref[config.startIconSlot] = startIcon, _ref), config.endIconSlot && (_ref2 = {}, _ref2[config.endIconSlot] = endIcon, _ref2), (_extends2 = {}, _extends2[config.contentSlot] = children, _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: !!link ? "a" : "button",
    props: _extends({}, omit.apply(void 0, [rest].concat(plasmicClass.internalArgProps, plasmicClass.internalVariantProps)), {
      ref: ref,
      disabled: isDisabled
    }, !!link && {
      href: link
    })
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function getStyleProps(props) {
  return pick(props, "className", "style");
}
function getDefaultPlasmicProps(plasmicClass, props) {
  return {
    plasmicProps: {
      variants: pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)),
      args: pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)),
      overrides: {}
    }
  };
}
var RE_DATA_PROP = /^(data-.*)$/;
function getDataProps(props) {
  return pickBy(props, function (k) {
    return RE_DATA_PROP.test(k);
  });
}

function asAriaCheckboxProps(props) {
  var ariaProps = _extends({}, props, {
    isSelected: props.isChecked,
    defaultSelected: props.defaultChecked
  });
  delete ariaProps["isChecked"];
  delete ariaProps["defaultChecked"];
  return ariaProps;
}
function useCheckbox(plasmicClass, props, config, ref) {
  var _overrides, _ref;
  if (ref === void 0) {
    ref = null;
  }
  var children = props.children,
    isDisabled = props.isDisabled,
    isIndeterminate = props.isIndeterminate;
  useEnsureSSRProvider();
  var inputRef = useRef(null);
  var rootRef = useRef(null);
  var ariaProps = asAriaCheckboxProps(props);
  var state = useToggleState(ariaProps);
  var _useAriaCheckbox = useCheckbox$1(ariaProps, state, inputRef),
    inputProps = _useAriaCheckbox.inputProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isCheckedVariant,
    active: state.isSelected
  }, {
    def: config.isIndeterminateVariant,
    active: isIndeterminate
  }, {
    def: config.noLabelVariant,
    active: !children
  }));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "label",
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, createElement(VisuallyHidden, null, createElement("input", Object.assign({}, inputProps, {
        ref: inputRef
      }))), children);
    }
  }, _overrides);
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.labelSlot ? (_ref = {}, _ref[config.labelSlot] = children, _ref) : {});
  var plumeState = useMemo(function () {
    return {
      setChecked: function setChecked(checked) {
        return state.setSelected(checked);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      focus: function focus() {
        var _inputRef$current;
        return (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;
        return (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      setChecked: function setChecked(checked) {
        return plumeState.setChecked(checked);
      }
    };
  }, [rootRef, inputRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      overrides: overrides,
      args: args
    },
    state: plumeState
  };
}

function deriveItemsFromProps(props, opts) {
  if (opts.itemsProp && opts.itemsProp in props) {
    if (!opts.ItemComponent || !opts.SectionComponent) {
      throw new Error("You may need to re-generate your Plasmic* files");
    }
    var items = props[opts.itemsProp];
    return deriveItemsFromItemsProp(items, {
      ItemComponent: opts.ItemComponent,
      SectionComponent: opts.SectionComponent
    });
  } else {
    return deriveItemsFromChildren(props.children, opts);
  }
}
function deriveItemsFromItemsProp(items, opts) {
  var _items$map;
  var ItemComponent = opts.ItemComponent,
    SectionComponent = opts.SectionComponent;
  var disabledKeys = [];
  var transform = function transform(item) {
    if (typeof item === "string") {
      return React__default.createElement(ItemComponent, {
        key: item,
        value: item
      }, item);
    } else if ("children" in item) {
      return React__default.createElement(SectionComponent, {
        key: item.title,
        title: item.title
      }, item.children.map(function (x) {
        return transform(x);
      }));
    } else {
      var _item$label;
      if (item.isDisabled) {
        disabledKeys.push(item.value);
      }
      return React__default.createElement(ItemComponent, {
        key: item.value,
        value: item.value,
        textValue: item.textValue,
        isDisabled: item.isDisabled
      }, (_item$label = item.label) != null ? _item$label : item.value);
    }
  };
  return {
    items: (_items$map = items == null ? void 0 : items.map(function (x) {
      return transform(x);
    })) != null ? _items$map : [],
    disabledKeys: disabledKeys
  };
}
/**
 * Given children of a component like Select or Menu, derive the items
 * that we will pass into the Collections API.  These will be
 * ReactElement<ItemLikeProps|SectionLikeProps>[].
 *
 * Will also assign keys to items by their index in the collection,
 * and collect the keys of disabled items.
 */
function deriveItemsFromChildren(children, opts) {
  if (!children) {
    return {
      items: [],
      disabledKeys: []
    };
  }
  var itemPlumeType = opts.itemPlumeType,
    sectionPlumeType = opts.sectionPlumeType,
    invalidChildError = opts.invalidChildError;
  // For Plume items without an explicit key, we assign a key as the index
  // of the collection.
  var itemCount = 0;
  var sectionCount = 0;
  var ensureValue = function ensureValue(element) {
    if (!propInChild(element, "value")) {
      if (opts.requireItemValue && PLUME_STRICT_MODE) {
        throw new Error("Must specify a \"value\" prop for " + getElementTypeName(element));
      } else {
        return cloneChild(element, {
          value: "" + itemCount++
        });
      }
    } else {
      // Still increment count even if key is present, so that the
      // auto-assigned key really reflects the index
      itemCount++;
      return element;
    }
  };
  var disabledKeys = [];
  var flattenedChildren = function flattenedChildren(children) {
    return toChildArray(children).flatMap(function (child) {
      if (React__default.isValidElement(child)) {
        if (child.type === React__default.Fragment) {
          return flattenedChildren(child.props.children);
        }
        var type = getPlumeType(child);
        if (type === itemPlumeType) {
          child = ensureValue(child);
          var childKey = getItemLikeKey(child);
          if (getChildProp(child, "isDisabled") && !!childKey) {
            disabledKeys.push(childKey);
          }
          return [child];
        }
        if (type === sectionPlumeType) {
          var _child$key;
          return [cloneChild(child, {
            // key of section doesn't actually matter, just needs
            // to be unique
            key: (_child$key = child.key) != null ? _child$key : "section-" + sectionCount++,
            children: flattenedChildren(getChildProp(child, "children"))
          })];
        }
      }
      if (PLUME_STRICT_MODE) {
        throw new Error(invalidChildError != null ? invalidChildError : "Unexpected child");
      } else {
        return [];
      }
    });
  };
  return {
    items: flattenedChildren(children),
    disabledKeys: disabledKeys
  };
}
function useDerivedItems(props, opts) {
  var children = props.children;
  var itemPlumeType = opts.itemPlumeType,
    sectionPlumeType = opts.sectionPlumeType,
    invalidChildError = opts.invalidChildError,
    requireItemValue = opts.requireItemValue,
    ItemComponent = opts.ItemComponent,
    SectionComponent = opts.SectionComponent,
    itemsProp = opts.itemsProp;
  var items = itemsProp ? props[itemsProp] : undefined;
  return React__default.useMemo(function () {
    return deriveItemsFromProps(props, {
      itemPlumeType: itemPlumeType,
      sectionPlumeType: sectionPlumeType,
      invalidChildError: invalidChildError,
      requireItemValue: requireItemValue,
      itemsProp: itemsProp,
      ItemComponent: ItemComponent,
      SectionComponent: SectionComponent
    });
  }, [children, items, itemPlumeType, sectionPlumeType, invalidChildError, requireItemValue, ItemComponent, SectionComponent]);
}
function useDerivedItemsFromChildren(children, opts) {
  var itemPlumeType = opts.itemPlumeType,
    sectionPlumeType = opts.sectionPlumeType,
    invalidChildError = opts.invalidChildError,
    requireItemValue = opts.requireItemValue;
  return React__default.useMemo(function () {
    return deriveItemsFromChildren(children, {
      itemPlumeType: itemPlumeType,
      sectionPlumeType: sectionPlumeType,
      invalidChildError: invalidChildError,
      requireItemValue: requireItemValue
    });
  }, [children, itemPlumeType, sectionPlumeType, invalidChildError, requireItemValue]);
}
/**
 * Given a Collection node, create the React element that we should use
 * to render it.
 */
function renderCollectionNode(node) {
  // node.rendered should already have our item-like or section-like Plume
  // component elements, so we just need to clone them with a secret
  // _node prop that we use to render.
  return cloneChild(node.rendered, {
    _node: node,
    key: node.key
  });
}
/**
 * Renders a item-like or section-like Plume component element into an
 * Item or a Section element.
 */
function renderAsCollectionChild(child, opts) {
  var plumeType = getPlumeType(child);
  if (plumeType === opts.itemPlumeType) {
    var _getChildProp;
    var option = child;
    // We look at the children passed to the item-like element, and derive key
    // or textValue from it if it is a string
    var content = getChildProp(option, "children");
    // The children render prop needs to return an <Item/>
    return React__default.createElement(Item
    // We use ItemLike.value if the user explicitly specified a value,
    // and we fallback to key.  If the user specified neither, then
    // the Collections API will generate a unique key for this item.
    , {
      // We use ItemLike.value if the user explicitly specified a value,
      // and we fallback to key.  If the user specified neither, then
      // the Collections API will generate a unique key for this item.
      key: getItemLikeKey(option),
      // textValue is either explicitly specified by the user, or we
      // try to derive it if `content` is a string.
      textValue: (_getChildProp = getChildProp(option, "textValue")) != null ? _getChildProp : isString(content) ? content : propInChild(option, "value") ? getChildProp(option, "value") : option.key,
      "aria-label": getChildProp(option, "aria-label")
    }, option);
  } else {
    var group = child;
    return React__default.createElement(Section
    // Note that we are using the whole section-like element as the title
    // here, and not group.props.title; we want the entire section-like
    // Plume element to end up as Node.rendered.
    , {
      // Note that we are using the whole section-like element as the title
      // here, and not group.props.title; we want the entire section-like
      // Plume element to end up as Node.rendered.
      title: group,
      "aria-label": getChildProp(group, "aria-label"),
      // We are flattening and deriving the descendant Options as items here.
      // group.props.children should've already been cleaned up by
      // deriveItemsFromChildren()
      items: getChildProp(group, "children")
    }, function (c) {
      return renderAsCollectionChild(c, opts);
    });
  }
}
function getItemLikeKey(element) {
  var _getChildProp2;
  return (_getChildProp2 = getChildProp(element, "value")) != null ? _getChildProp2 : element.key;
}
// PlasmicLoader-aware function to get prop from child.
function getChildProp(child, prop) {
  return "componentProps" in child.props ? child.props.componentProps[prop] : child.props[prop];
}
// PlasmicLoader-aware function to check `if (prop in element.props)`.
function propInChild(child, prop) {
  return "componentProps" in child.props ? prop in child.props.componentProps : prop in child.props;
}
// PlasmicLoader-aware function to clone React element.
function cloneChild(child, props) {
  if (child.type.getPlumeType) {
    // If React element has getPlumeType(), assume that it is PlasmicLoader,
    // so add nodeProps to componentProps instead of element props.
    return React__default.cloneElement(child, _extends({
      componentProps: _extends({}, child.props.componentProps, props)
    }, props.key ? {
      key: props.key
    } : {}));
  }
  return React__default.cloneElement(child, props);
}

var TriggeredOverlayContext = /*#__PURE__*/createContext(undefined);

var MenuContext = /*#__PURE__*/createContext(undefined);

var _excluded$5 = ["children"];
var COLLECTION_OPTS = {
  itemPlumeType: "menu-item",
  sectionPlumeType: "menu-group"
};
/**
 * Converts props from BaseMenuProps to react-aria's useMenu() props.
 */
function asAriaMenuProps(props) {
  var children = props.children,
    rest = _objectWithoutPropertiesLoose(props, _excluded$5);
  var _useDerivedItemsFromC = useDerivedItemsFromChildren(children, _extends({}, COLLECTION_OPTS, {
      invalidChildError: "Can only use Menu.Item and Menu.Group as children to Menu",
      requireItemValue: false
    })),
    items = _useDerivedItemsFromC.items,
    disabledKeys = _useDerivedItemsFromC.disabledKeys;
  var collectionChildRenderer = useCallback(function (child) {
    return renderAsCollectionChild(child, COLLECTION_OPTS);
  }, []);
  return {
    ariaProps: _extends({}, rest, {
      children: collectionChildRenderer,
      items: items,
      disabledKeys: disabledKeys
    })
  };
}
function useMenu(plasmicClass, props, config, ref) {
  var _overrides, _extends2;
  if (ref === void 0) {
    ref = null;
  }
  useEnsureSSRProvider();
  var _asAriaMenuProps = asAriaMenuProps(props),
    ariaProps = _asAriaMenuProps.ariaProps;
  var triggerContext = useContext(TriggeredOverlayContext);
  var rootRef = useRef(null);
  var state = useTreeState(ariaProps);
  var menuListRef = useRef(null);
  var _useAriaMenu = useMenu$1(_extends({}, ariaProps, {
      autoFocus: triggerContext == null ? void 0 : triggerContext.autoFocus
    }), state, menuListRef),
    menuProps = _useAriaMenu.menuProps;
  var contextValue = useMemo(function () {
    return {
      state: state,
      menuProps: props
    };
  }, [state, props]);
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    })
  }, _overrides[config.itemsContainer] = {
    as: "ul",
    props: mergeProps(menuProps, {
      ref: menuListRef,
      style: _extends({}, noOutline())
    })
  }, _overrides);
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.itemsSlot] = createElement(MenuContext.Provider, {
    value: contextValue
  }, Array.from(state.collection).map(function (node) {
    return renderCollectionNode(node);
  })), _extends2));
  var plumeState = useMemo(function () {
    return {
      getFocusedValue: function getFocusedValue() {
        return state.selectionManager.focusedKey;
      },
      setFocusedValue: function setFocusedValue(value) {
        return state.selectionManager.setFocusedKey(value);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getFocusedValue: function getFocusedValue() {
        return plumeState.getFocusedValue();
      },
      setFocusedValue: function setFocusedValue(key) {
        return plumeState.setFocusedValue(key);
      }
    };
  }, [rootRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}

function useMenuGroup(plasmicClass, props, config) {
  var _extends2, _overrides;
  var context = useContext(MenuContext);
  var node = props._node;
  if (!context || !node) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Menu.Group within a Menu component.");
    }
    return getDefaultPlasmicProps(plasmicClass, props);
  }
  var _useMenuSection = useMenuSection({
      heading: props.title,
      "aria-label": props["aria-label"]
    }),
    headingProps = _useMenuSection.headingProps,
    groupProps = _useMenuSection.groupProps;
  var _useSeparator = useSeparator({
      elementType: "li"
    }),
    separatorProps = _useSeparator.separatorProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.noTitleVariant,
    active: !props.title
  }, {
    def: config.isFirstVariant,
    active: context.state.collection.getFirstKey() === node.key
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.titleSlot] = props.title, _extends2[config.itemsSlot] = Array.from(node.childNodes).map(function (childNode) {
    return renderCollectionNode(childNode);
  }), _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: getStyleProps(props)
  }, _overrides[config.separator] = {
    props: _extends({}, separatorProps),
    as: "li"
  }, _overrides[config.titleContainer] = _extends({
    props: _extends({
      role: "presentation"
    }, headingProps)
  }, !props.title && {
    render: function render() {
      return null;
    }
  }), _overrides[config.itemsContainer] = {
    props: _extends({}, groupProps),
    as: "ul"
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useMenuItem(plasmicClass, props, config) {
  var _extends2, _overrides;
  var menuContext = useContext(MenuContext);
  var triggerContext = useContext(TriggeredOverlayContext);
  if (!menuContext) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Menu.Item within a Menu component.");
    }
    return getDefaultPlasmicProps(plasmicClass, props);
  }
  var children = props.children,
    onAction = props.onAction;
  var state = menuContext.state,
    menuProps = menuContext.menuProps;
  // We pass in the Node secretly as an undocumented prop from <Select />
  var node = props._node;
  var isDisabled = state.disabledKeys.has(node.key);
  var isHighlighted = state.selectionManager.isFocused && state.selectionManager.focusedKey === node.key;
  var ref = useRef(null);
  var _useAriaMenuItem = useMenuItem$1(mergeProps({
      // We need to merge both the onAction on MenuItem and the onAction
      // on Menu
      onAction: onAction
    }, {
      onAction: menuProps.onAction,
      onClose: triggerContext == null ? void 0 : triggerContext.state.close
    }, {
      isDisabled: isDisabled,
      "aria-label": node && node["aria-label"],
      key: node.key,
      isVirtualized: false,
      closeOnSelect: true
    }), state, ref),
    menuItemProps = _useAriaMenuItem.menuItemProps,
    labelProps = _useAriaMenuItem.labelProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isHighlightedVariant,
    active: isHighlighted
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.labelSlot] = children, _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "li",
    props: mergeProps(menuItemProps, {
      ref: ref,
      style: noOutline()
    })
  }, _overrides[config.labelContainer] = {
    props: _extends({}, labelProps)
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

/**
 * A menu trigger hook that combines react-aria's useMenuTrigger, useAriaMenuTrigger,
 * useOverlayPosition, useOverlay, and usePress
 */
function useMenuTrigger(opts, state) {
  var triggerRef = opts.triggerRef,
    isDisabled = opts.isDisabled,
    placement = opts.placement,
    menuMatchTriggerWidth = opts.menuMatchTriggerWidth,
    menuWidth = opts.menuWidth,
    menu = opts.menu;
  var _useAriaMenuTrigger = useMenuTrigger$1({
      type: "menu",
      isDisabled: isDisabled
    }, state, triggerRef),
    triggerPressProps = _useAriaMenuTrigger.menuTriggerProps,
    menuProps = _useAriaMenuTrigger.menuProps;
  var _usePress = usePress(_extends({}, triggerPressProps, {
      isDisabled: isDisabled
    })),
    triggerProps = _usePress.pressProps;
  var makeMenu = function makeMenu() {
    var realMenu = typeof menu === "function" ? menu() : menu;
    if (!realMenu) {
      return null;
    }
    if (getPlumeType(realMenu) !== "menu") {
      if (PLUME_STRICT_MODE) {
        throw new Error("Must use an instance of the Menu component.");
      }
      return null;
    }
    return cloneElement(realMenu, mergeProps(realMenu.props, menuProps));
  };
  var triggerContext = useMemo(function () {
    var _state$focusStrategy;
    return {
      triggerRef: triggerRef,
      state: state,
      autoFocus: (_state$focusStrategy = state.focusStrategy) != null ? _state$focusStrategy : true,
      placement: placement,
      overlayMatchTriggerWidth: menuMatchTriggerWidth,
      overlayMinTriggerWidth: true,
      overlayWidth: menuWidth
    };
  }, [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]);
  return {
    triggerProps: triggerProps,
    makeMenu: makeMenu,
    triggerContext: triggerContext
  };
}

function DropdownMenu(props) {
  var isOpen = props.isOpen,
    defaultOpen = props.defaultOpen,
    onOpenChange = props.onOpenChange,
    children = props.children,
    placement = props.placement,
    menu = props.menu;
  var triggerRef = useRef(null);
  var state = useMenuTriggerState({
    isOpen: isOpen,
    defaultOpen: defaultOpen,
    onOpenChange: onOpenChange,
    shouldFlip: true
  });
  var _useMenuTrigger = useMenuTrigger({
      triggerRef: triggerRef,
      placement: placement,
      menu: menu
    }, state),
    triggerProps = _useMenuTrigger.triggerProps,
    makeMenu = _useMenuTrigger.makeMenu,
    triggerContext = _useMenuTrigger.triggerContext;
  return createElement(TriggeredOverlayContext.Provider, {
    value: triggerContext
  }, cloneElement(children, mergeProps(children.props, triggerProps, {
    ref: triggerRef
  })), state.isOpen && makeMenu());
}

function useMenuButton(plasmicClass, props, config, outerRef) {
  var _extends2, _overrides;
  if (outerRef === void 0) {
    outerRef = null;
  }
  var placement = props.placement,
    isOpen = props.isOpen,
    defaultOpen = props.defaultOpen,
    onOpenChange = props.onOpenChange,
    isDisabled = props.isDisabled,
    menu = props.menu,
    autoFocus = props.autoFocus,
    menuMatchTriggerWidth = props.menuMatchTriggerWidth,
    menuWidth = props.menuWidth;
  useEnsureSSRProvider();
  var rootRef = useRef(null);
  var triggerRef = useRef(null);
  var state = useMenuTriggerState({
    isOpen: isOpen,
    defaultOpen: defaultOpen,
    onOpenChange: onOpenChange,
    shouldFlip: true
  });
  var _useMenuTrigger = useMenuTrigger({
      isDisabled: isDisabled,
      triggerRef: triggerRef,
      placement: placement,
      menuMatchTriggerWidth: menuMatchTriggerWidth,
      menuWidth: menuWidth,
      menu: menu
    }, state),
    triggerProps = _useMenuTrigger.triggerProps,
    makeMenu = _useMenuTrigger.makeMenu,
    triggerContext = _useMenuTrigger.triggerContext;
  var _useFocusable = useFocusable(props, triggerRef),
    triggerFocusProps = _useFocusable.focusableProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isOpenVariant,
    active: state.isOpen
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.menuSlot] = state.isOpen ? makeMenu() : undefined, _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    wrapChildren: function wrapChildren(children) {
      return createElement(TriggeredOverlayContext.Provider, {
        value: triggerContext
      }, children);
    },
    props: {
      ref: rootRef
    }
  }, _overrides[config.trigger] = {
    props: mergeProps(triggerProps, triggerFocusProps, getStyleProps(props), pick(props, "title"), {
      ref: triggerRef,
      autoFocus: autoFocus,
      disabled: !!isDisabled,
      // Make sure this button is not interpreted as submit
      type: "button"
    })
  }, _overrides);
  var plumeState = useMemo(function () {
    return {
      open: function open() {
        return state.open();
      },
      close: function close() {
        return state.close();
      },
      isOpen: function isOpen() {
        return state.isOpen;
      }
    };
  }, [state]);
  useImperativeHandle(outerRef, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getTrigger: function getTrigger() {
        return triggerRef.current;
      },
      focus: function focus() {
        return triggerRef.current && triggerRef.current.focus();
      },
      blur: function blur() {
        return triggerRef.current && triggerRef.current.blur();
      },
      open: plumeState.open,
      close: plumeState.close,
      isOpen: plumeState.isOpen
    };
  }, [rootRef, triggerRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}

var SelectContext = /*#__PURE__*/createContext(undefined);

var _excluded$6 = ["value", "defaultValue", "children", "onChange", "placement", "menuMatchTriggerWidth", "menuWidth"];
var COLLECTION_OPTS$1 = {
  itemPlumeType: "select-option",
  sectionPlumeType: "select-option-group"
};
/**
 * Converts props in our BaseSelectProps into props that react-aria's
 * useSelect() understands.
 *
 * Because we're not exposing the Collections API (see ./index.tsx),
 * we are converting our own API into props for useSelect.
 *
 * Specifically, in Plume's API,
 * - `children` flattens to a list of ReactElements of type Select.Option
 *   or Select.OptionGroup
 *
 * and we map it this way to the Collections API:
 * - `items` is a list of those flattened ReactElements from `children`!
 * - `children`, as a render prop, is supposed to take one of the `items`
 *   and return a `Section` or `Item` element. We take an Option/OptionGroup
 *   element, and use its props to render the appropriate `Section` or
 *   `Item`. The "trick" here is that we then stuff the Option element as
 *   `Item.children`, and the OptionGroup element as `Section.title`.
 *
 * When the Collections API does its work deriving `Node`s, the corresponding
 * Option/OptionGroup ReactElements will end up as `Node.rendered`.
 *
 * Then, when we are actually rendering the content of the dropdown, we
 * iterate through each collected `Node`, and renders
 * React.cloneElement(Node.rendered, {_node: node}).  This "secretly" passes
 * the derived collection `Node` as a prop to Option and OptionGroup, and they
 * can make use of the derived `Node.key` etc in their rendering functions.
 *
 * One thing to note here is that we never "rendered" the Option/OptionGroup
 * React elements that the user constructed; instead, we just looked at the
 * props used on those elements, and passed those onto the Collections API.
 * What gets rendered to the screen is the cloned version of these elements
 * with the secret derived `_node` prop.  That means Option and OptionGroup
 * render functions can assume that _node is passed in.
 */
function useAriaSelectProps(props, config) {
  var value = props.value,
    defaultValue = props.defaultValue,
    onChange = props.onChange,
    rest = _objectWithoutPropertiesLoose(props, _excluded$6);
  var _useDerivedItems = useDerivedItems(props, _extends({}, COLLECTION_OPTS$1, {
      invalidChildError: "Can only use Select.Option and Select.OptionGroup as children to Select",
      requireItemValue: true,
      ItemComponent: config.OptionComponent,
      SectionComponent: config.OptionGroupComponent,
      itemsProp: "options"
    })),
    items = _useDerivedItems.items,
    disabledKeys = _useDerivedItems.disabledKeys;
  var collectionChildRenderer = useCallback(function (child) {
    return renderAsCollectionChild(child, COLLECTION_OPTS$1);
  }, []);
  var onSelectionChange = useMemo(function () {
    if (onChange) {
      return function (val) {
        return onChange(val == null || val === "null" ? null : val);
      };
    } else {
      return undefined;
    }
  }, [onChange]);
  return {
    ariaProps: _extends({}, rest, {
      children: collectionChildRenderer,
      onSelectionChange: onSelectionChange,
      items: items,
      disabledKeys: disabledKeys,
      defaultSelectedKey: defaultValue
    }, "value" in props && {
      selectedKey: value != null ? value : null
    })
  };
}
function useSelect(plasmicClass, props, config, ref) {
  var _overrides, _extends2;
  if (ref === void 0) {
    ref = null;
  }
  useEnsureSSRProvider();
  var _useAriaSelectProps = useAriaSelectProps(props, config),
    ariaProps = _useAriaSelectProps.ariaProps;
  var placement = props.placement;
  var state = useSelectState(ariaProps);
  var triggerRef = useRef(null);
  var rootRef = useRef(null);
  var isDisabled = props.isDisabled,
    name = props.name,
    menuWidth = props.menuWidth,
    menuMatchTriggerWidth = props.menuMatchTriggerWidth,
    autoFocus = props.autoFocus,
    placeholder = props.placeholder,
    selectedContent = props.selectedContent;
  var canvasCtx = usePlasmicCanvasContext();
  var _useAriaSelect = useSelect$1(ariaProps, state, triggerRef),
    triggerPressProps = _useAriaSelect.triggerProps,
    menuProps = _useAriaSelect.menuProps;
  var _usePress = usePress(_extends({}, triggerPressProps, {
      isDisabled: isDisabled
    })),
    triggerProps = _usePress.pressProps;
  var triggerContent = state.selectedItem ? selectedContent != null ? selectedContent : getChildProp(state.selectedItem.value, "children") : null;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isOpenVariant,
    active: state.isOpen
  }, {
    def: config.placeholderVariant,
    active: !state.selectedItem
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));
  var triggerContext = useMemo(function () {
    return {
      triggerRef: triggerRef,
      state: state,
      placement: placement,
      overlayMatchTriggerWidth: menuMatchTriggerWidth,
      overlayMinTriggerWidth: true,
      overlayWidth: menuWidth
    };
  }, [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]);
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, !canvasCtx && createElement(HiddenSelect, {
        state: state,
        triggerRef: triggerRef,
        name: name,
        isDisabled: isDisabled
      }), children);
    }
  }, _overrides[config.trigger] = {
    props: mergeProps(canvasCtx ? {} : triggerProps, {
      ref: triggerRef,
      autoFocus: autoFocus,
      disabled: !!isDisabled,
      // Don't trigger form submission!
      type: "button"
    })
  }, _overrides[config.overlay] = {
    wrap: function wrap(content) {
      return createElement(TriggeredOverlayContext.Provider, {
        value: triggerContext
      }, content);
    }
  }, _overrides[config.optionsContainer] = {
    wrap: function wrap(content) {
      return createElement(ListBoxWrapper, {
        state: state,
        menuProps: menuProps
      }, content);
    }
  }, _overrides);
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.triggerContentSlot] = triggerContent, _extends2[config.placeholderSlot] = placeholder, _extends2[config.optionsSlot] = createElement(SelectContext.Provider, {
    value: state
  }, Array.from(state.collection).map(function (node) {
    return renderCollectionNode(node);
  })), _extends2));
  var plumeState = useMemo(function () {
    return {
      open: function open() {
        return state.open();
      },
      close: function close() {
        return state.close();
      },
      isOpen: function isOpen() {
        return state.isOpen;
      },
      getSelectedValue: function getSelectedValue() {
        return state.selectedKey ? "" + state.selectedKey : null;
      },
      setSelectedValue: function setSelectedValue(key) {
        return state.setSelectedKey(key);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getTrigger: function getTrigger() {
        return triggerRef.current;
      },
      focus: function focus() {
        var _triggerRef$current;
        return (_triggerRef$current = triggerRef.current) == null ? void 0 : _triggerRef$current.focus();
      },
      blur: function blur() {
        var _triggerRef$current2;
        return (_triggerRef$current2 = triggerRef.current) == null ? void 0 : _triggerRef$current2.blur();
      },
      open: function open() {
        return plumeState.open();
      },
      close: function close() {
        return plumeState.close();
      },
      isOpen: function isOpen() {
        return plumeState.isOpen();
      },
      getSelectedValue: function getSelectedValue() {
        return plumeState.getSelectedValue();
      },
      setSelectedValue: function setSelectedValue(key) {
        return plumeState.setSelectedValue(key);
      }
    };
  }, [rootRef, triggerRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}
function ListBoxWrapper(props) {
  var state = props.state,
    menuProps = props.menuProps,
    children = props.children;
  var ref = useRef(null);
  var canvasCtx = usePlasmicCanvasContext();
  var _useListBox = useListBox(_extends({}, menuProps, {
      isVirtualized: false,
      autoFocus: state.focusStrategy || true,
      disallowEmptySelection: true
    }), state, ref),
    listBoxProps = _useListBox.listBoxProps;
  return cloneElement(children, mergeProps(children.props, canvasCtx ? {} : listBoxProps, {
    style: noOutline(),
    ref: ref
  }));
}

function useSelectOption(plasmicClass, props, config, outerRef) {
  var _extends2, _overrides;
  if (outerRef === void 0) {
    outerRef = null;
  }
  var state = useContext(SelectContext);
  if (!state) {
    // If no context, then we are being incorrectly used.  Complain or just don't
    // bother installing any hooks.  It's okay to violate rules of hooks here
    // because this instance won't suddenly be used correctly in another render.
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Select.Option within a Select component.");
    }
    return getDefaultPlasmicProps(plasmicClass, props);
  }
  var children = props.children;
  var canvasCtx = usePlasmicCanvasContext();
  var rootRef = useRef(null);
  var onRef = mergeRefs(rootRef, outerRef);
  // We pass in the Node secretly as an undocumented prop from <Select />
  var node = props._node;
  var isSelected = state.selectionManager.isSelected(node.key);
  var isDisabled = state.disabledKeys.has(node.key);
  var isHighlighted = state.selectionManager.isFocused && state.selectionManager.focusedKey === node.key;
  var _useAriaOption = useOption({
      isSelected: isSelected,
      isDisabled: isDisabled,
      "aria-label": node && node["aria-label"],
      key: node.key,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      isVirtualized: false,
      shouldUseVirtualFocus: !!canvasCtx
    }, state, rootRef),
    optionProps = _useAriaOption.optionProps,
    labelProps = _useAriaOption.labelProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isSelectedVariant,
    active: isSelected
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isHighlightedVariant,
    active: isHighlighted
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.labelSlot] = children, _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(canvasCtx ? {} : optionProps, getStyleProps(props), {
      ref: onRef,
      style: noOutline()
    })
  }, _overrides[config.labelContainer] = {
    props: labelProps
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useSelectOptionGroup(plasmicClass, props, config) {
  var _extends2, _overrides;
  var state = useContext(SelectContext);
  // `node` should exist if the OptionGroup was instantiated properly
  // within a Select
  var node = props._node;
  if (!state || !node) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Select.OptionGroup within a Select component.");
    }
    return getDefaultPlasmicProps(plasmicClass, props);
  }
  var _useListBoxSection = useListBoxSection({
      heading: props.title,
      "aria-label": props["aria-label"]
    }),
    headingProps = _useListBoxSection.headingProps,
    groupProps = _useListBoxSection.groupProps;
  var _useSeparator = useSeparator({
      elementType: "li"
    }),
    separatorProps = _useSeparator.separatorProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.noTitleVariant,
    active: !props.title
  }, {
    def: config.isFirstVariant,
    active: state.collection.getFirstKey() === node.key
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.titleSlot] = props.title, _extends2[config.optionsSlot] = Array.from(node.childNodes).map(function (childNode) {
    return renderCollectionNode(childNode);
  }), _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: getStyleProps(props)
  }, _overrides[config.separator] = {
    props: _extends({}, separatorProps)
  }, _overrides[config.titleContainer] = _extends({
    props: _extends({
      role: "presentation"
    }, headingProps)
  }, !props.title && {
    render: function render() {
      return null;
    }
  }), _overrides[config.optionsContainer] = {
    props: _extends({}, groupProps)
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function asAriaSwitchProps(props) {
  var ariaProps = _extends({}, props, {
    isSelected: props.isChecked,
    defaultSelected: props.defaultChecked
  });
  delete ariaProps["isChecked"];
  delete ariaProps["defaultChecked"];
  return ariaProps;
}
function useSwitch(plasmicClass, props, config, ref) {
  var _overrides, _ref;
  if (ref === void 0) {
    ref = null;
  }
  var children = props.children,
    isDisabled = props.isDisabled;
  useEnsureSSRProvider();
  var inputRef = useRef(null);
  var rootRef = useRef(null);
  var ariaProps = asAriaSwitchProps(props);
  var state = useToggleState(ariaProps);
  var _useAriaSwitch = useSwitch$1(ariaProps, state, inputRef),
    inputProps = _useAriaSwitch.inputProps;
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isCheckedVariant,
    active: state.isSelected
  }, {
    def: config.noLabelVariant,
    active: !children
  }));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "label",
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, createElement(VisuallyHidden, null, createElement("input", Object.assign({}, inputProps, {
        ref: inputRef
      }))), children);
    }
  }, _overrides);
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.labelSlot ? (_ref = {}, _ref[config.labelSlot] = children, _ref) : {});
  var plumeState = useMemo(function () {
    return {
      setChecked: function setChecked(checked) {
        return state.setSelected(checked);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      focus: function focus() {
        var _inputRef$current;
        return (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;
        return (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      setChecked: function setChecked(checked) {
        return plumeState.setChecked(checked);
      }
    };
  }, [rootRef, inputRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      overrides: overrides,
      args: args
    },
    state: plumeState
  };
}

var _excluded$7 = ["isDisabled", "startIcon", "endIcon", "showStartIcon", "showEndIcon", "className", "style", "inputClassName", "inputStyle"];
function useTextInput(plasmicClass, props, config, ref) {
  var _ref, _ref2, _overrides;
  if (ref === void 0) {
    ref = null;
  }
  var isDisabled = props.isDisabled,
    startIcon = props.startIcon,
    endIcon = props.endIcon,
    showStartIcon = props.showStartIcon,
    showEndIcon = props.showEndIcon,
    className = props.className,
    style = props.style,
    inputClassName = props.inputClassName,
    inputStyle = props.inputStyle,
    rest = _objectWithoutPropertiesLoose(props, _excluded$7);
  var rootRef = useRef(null);
  var inputRef = useRef(null);
  useImperativeHandle(ref, function () {
    return {
      focus: function focus() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  }, [rootRef, inputRef]);
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.showStartIconVariant,
    active: showStartIcon
  }, {
    def: config.showEndIconVariant,
    active: showEndIcon
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.startIconSlot && (_ref = {}, _ref[config.startIconSlot] = startIcon, _ref), config.endIconSlot && (_ref2 = {}, _ref2[config.endIconSlot] = endIcon, _ref2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: {
      ref: rootRef,
      className: className,
      style: style
    }
  }, _overrides[config.input] = {
    props: _extends({}, omit.apply(void 0, [rest].concat(plasmicClass.internalArgProps.filter(function (prop) {
      return prop !== "required";
    }), plasmicClass.internalVariantProps)), {
      disabled: isDisabled,
      ref: inputRef,
      className: inputClassName,
      style: inputStyle
    })
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useTriggeredOverlay(plasmicClass, props, config, outerRef, isDismissable) {
  var _extends2, _overrides;
  if (outerRef === void 0) {
    outerRef = null;
  }
  if (isDismissable === void 0) {
    isDismissable = true;
  }
  var overlayRef = useRef(null);
  var onOverlayRef = mergeRefs(overlayRef, outerRef);
  var context = useContext(TriggeredOverlayContext);
  if (!context) {
    // If no context, then we are not being correctly used.  Either complain, or
    // exit early.  It's okay to exit early and break the rules of React hooks
    // because we won't suddenly have the appropriate context anyway for this instance.
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a triggered overlay with a TriggeredOverlayContext");
    }
    return getDefaultPlasmicProps(plasmicClass, props);
  }
  var children = props.children;
  var triggerRef = context.triggerRef,
    placement = context.placement,
    overlayMatchTriggerWidth = context.overlayMatchTriggerWidth,
    overlayMinTriggerWidth = context.overlayMinTriggerWidth,
    overlayWidth = context.overlayWidth,
    state = context.state;
  // Measure the width of the trigger to inform the width of the menu (below).
  var _React$useState = useState(false),
    isRendered = _React$useState[0],
    setRendered = _React$useState[1];
  var triggerWidth = triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth) ? triggerRef.current.offsetWidth : undefined;
  useIsomorphicLayoutEffect(function () {
    if (!isRendered && triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth)) {
      setRendered(true);
    }
  }, [triggerRef, isRendered, overlayMatchTriggerWidth, overlayMinTriggerWidth]);
  var _useOverlay = useOverlay({
      isOpen: state.isOpen,
      onClose: state.close,
      isDismissable: isDismissable,
      shouldCloseOnBlur: true
    }, overlayRef),
    overlayAriaProps = _useOverlay.overlayProps;
  var _useOverlayPosition = useOverlayPosition({
      targetRef: triggerRef,
      overlayRef: overlayRef,
      placement: placement != null ? placement : "bottom left",
      shouldFlip: true,
      isOpen: state.isOpen,
      onClose: state.close,
      containerPadding: 0
    }),
    overlayPositionProps = _useOverlayPosition.overlayProps,
    updatePosition = _useOverlayPosition.updatePosition,
    placementAxis = _useOverlayPosition.placement;
  useIsomorphicLayoutEffect(function () {
    if (state.isOpen) {
      requestAnimationFrame(function () {
        updatePosition();
      });
    }
  }, [state.isOpen, updatePosition]);
  var overlayProps = mergeProps({
    style: {
      left: "auto",
      right: "auto",
      top: "auto",
      bottom: "auto",
      position: "absolute",
      width: overlayWidth != null ? overlayWidth : overlayMatchTriggerWidth ? triggerWidth : "auto",
      minWidth: overlayMinTriggerWidth ? triggerWidth : "auto"
    }
  }, overlayAriaProps, overlayPositionProps);
  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isPlacedTopVariant,
    active: placementAxis === "top"
  }, {
    def: config.isPlacedBottomVariant,
    active: placementAxis === "bottom"
  }, {
    def: config.isPlacedLeftVariant,
    active: placementAxis === "left"
  }, {
    def: config.isPlacedRightVariant,
    active: placementAxis === "right"
  }));
  var canvasCtx = usePlasmicCanvasContext();
  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.contentSlot] = canvasCtx ? children : createElement(FocusScope, {
    restoreFocus: true
  }, createElement(DismissButton, {
    onDismiss: state.close
  }), children), _extends2));
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(overlayProps, getStyleProps(props), {
      ref: onOverlayRef
    }),
    wrap: function wrap(root) {
      if (typeof document !== "undefined") {
        return createPortal(root, document.body);
      } else {
        // Possibly being invoked on the server during SSR; no need to
        // bother with a portal in that case.
        return root;
      }
    }
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

export { DropdownMenu, PlasmicHead, PlasmicIcon, PlasmicImg, PlasmicLink, PlasmicPageGuard, PlasmicRootProvider, PlasmicSlot, SelectContext, Stack, Trans, TriggeredOverlayContext, classNames, createPlasmicElementProxy, createUseScreenVariants, deriveRenderOpts, ensureGlobalVariants, genTranslatableString, generateStateOnChangeProp, generateStateValueProp, getDataProps, getStateCellsInPlasmicProxy, getStateSpecInPlasmicProxy, hasVariant, isPlasmicStateProxy, makeFragment, mergeVariantsWithStates, omit, pick, plasmicHeadMeta, renderPlasmicSlot, set, setPlumeStrictMode, useButton, useCheckbox, useDollarState, useIsSSR, useMenu, useMenuButton, useMenuGroup, useMenuItem, useSelect, useSelectOption, useSelectOptionGroup, useSwitch, useTextInput, useTrigger, useTriggeredOverlay, wrapWithClassName };
//# sourceMappingURL=react-web.esm.js.map
