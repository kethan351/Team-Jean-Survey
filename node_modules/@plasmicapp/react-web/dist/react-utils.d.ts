import React from "react";
export declare const isBrowser: boolean;
export declare const NONE: unique symbol;
export declare const useIsomorphicLayoutEffect: typeof React.useLayoutEffect;
export declare function createElementWithChildren(elementType: any, props: any, children: React.ReactNode): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, any> | null) | (new (props: any) => React.Component<any, any, any>)> | React.CElement<any, React.Component<any, any, any>>;
export declare function ensureNotArray(children: React.ReactNode): any;
/**
 * Flattens ReactNode into an array of ReactChild, but does NOT replace
 * missing keys with array index, as React.Children.toArray() does.
 */
export declare function toChildArray(children: React.ReactNode): React.ReactChild[];
export declare function isReactText(child: React.ReactNode): child is React.ReactText;
export declare function isReactChild(child: React.ReactNode): child is React.ReactChild;
export declare function isReactFragment(child: React.ReactNode): child is React.ReactElement;
export declare function isReactNode(x: any): boolean;
export declare type StrictProps<T, TExpected> = Exclude<keyof T, keyof TExpected> extends never ? {} : Partial<"Unexpected extraneous props">;
export declare type HTMLElementRefOf<T extends keyof JSX.IntrinsicElements> = Exclude<React.ComponentProps<T>["ref"], string>;
export declare function mergeProps(props: Record<string, any>, ...restProps: Record<string, any>[]): Record<string, any>;
export declare function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]): (value: T) => void;
export declare function mergePropVals(name: string, val1: any, val2: any): any;
export declare function getElementTypeName(element: React.ReactElement): any;
