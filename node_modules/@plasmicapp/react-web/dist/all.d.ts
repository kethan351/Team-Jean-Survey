import * as React from 'react';
import React__default, { AriaAttributes, DOMAttributes as DOMAttributes$1, AriaRole, CSSProperties, Key, ReactNode, ReactElement, FocusEvent, KeyboardEvent as KeyboardEvent$1, SyntheticEvent } from 'react';

// LICENSE is MIT
//
// Copyright (c) 2018
//   Dave Keen <http://www.keendevelopment.ch>
//   Adi Dahiya <https://github.com/adidahiya>
//   Jason Killian <https://github.com/JKillian>
//   Sean Kelley <https://github.com/seansfkelley>
//   Michal Adamczyk <https://github.com/mradamczyk>
//   Marvin Hagemeister <https://github.com/marvinhagemeister>

type Value = string | number | boolean | undefined | null;
type Mapping = { [key: string]: any };
type Argument = Value | Mapping | Argument[];

declare function classNames$1(...args: Argument[]): string;

interface PlasmicPageGuardProps {
    appId: string;
    authorizeEndpoint: string;
    minRole?: string;
    canTriggerLogin: boolean;
    children: React__default.ReactNode;
}
declare function PlasmicPageGuard(props: PlasmicPageGuardProps): number | boolean | React__default.ReactFragment | JSX.Element | null | undefined;

declare function pick<T extends {}>(obj: T, ...keys: (string | number | symbol)[]): Partial<T>;
declare function omit<T extends {}>(obj: T, ...keys: (keyof T)[]): Partial<T>;

declare type StrictProps<T, TExpected> = Exclude<keyof T, keyof TExpected> extends never ? {} : Partial<"Unexpected extraneous props">;
declare type HTMLElementRefOf<T extends keyof JSX.IntrinsicElements> = Exclude<React__default.ComponentProps<T>["ref"], string>;

// Type definitions for dlv 1.1

declare function dlv(object: object, key: string | Array<string | number>, defaultValue?: any): any;

declare type InitFuncEnv = {
    $props: Record<string, any>;
    $state: Record<string, any>;
    $queries?: Record<string, any>;
    $ctx?: Record<string, any>;
};
declare type NoUndefinedField<T> = {
    [P in keyof T]-?: T[P];
};
declare type InitFunc<T> = (env: NoUndefinedField<InitFuncEnv>) => T;
declare type ObjectPath = (string | number)[];
interface $StateSpec<T> {
    path: string;
    initFunc?: InitFunc<T>;
    initVal?: T;
    type: "private" | "readonly" | "writable";
    valueProp?: string;
    onChangeProp?: string;
    isImmutable?: boolean;
    variableType: "text" | "number" | "boolean" | "array" | "object" | "variant";
}
interface $State {
    [key: string]: any;
    registerInitFunc?: (path: string, f: InitFunc<any>, repetitonIndex?: number[]) => any;
}
interface Internal$StateSpec<T> extends $StateSpec<T> {
    isRepeated: boolean;
    pathObj: (string | symbol)[];
}

declare function generateStateOnChangeProp($state: $State, path: ObjectPath): (val: any) => void;
declare function generateStateValueProp($state: $State, path: ObjectPath): any;
declare function isPlasmicStateProxy(obj: any): boolean;
declare function getStateCellsInPlasmicProxy(obj: any): {
    realPath: ObjectPath;
    path: string;
}[];
declare function getStateSpecInPlasmicProxy(obj: any, path: ObjectPath): {
    spec: Internal$StateSpec<any>;
    isImplicitStateArray: boolean;
} | undefined;
/**
 * Forked from https://github.com/lukeed/dset
 * Changes: fixed setting a deep value to a proxy object
 */
declare function set(obj: any, keys: any, val: any): void;

declare function useDollarState(specs: $StateSpec<any>[], ...rest: any[]): $State;

interface Variants {
    [vg: string]: any;
}
declare type MultiChoiceArg<M extends string> = M | M[] | {
    [v in M]?: boolean;
};
declare type SingleChoiceArg<M extends string> = M;
declare type SingleBooleanChoiceArg<M extends string> = M | boolean;
interface OverrideTwiddle {
    wrapChildren?: (children: React.ReactNode) => React.ReactNode;
    wrap?: (node: React.ReactNode) => React.ReactNode;
}
declare type DefaultOverride<C extends React.ElementType> = {
    type: "default";
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
declare type AsOverride<C extends React.ElementType> = {
    type: "as";
    as: C;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
declare type RenderOverride<C extends React.ElementType> = {
    type: "render";
    render: (props: React.ComponentProps<C>, Comp: C) => React.ReactNode;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
declare type Flex<DefaultElementType extends React.ElementType> = (Omit<DefaultOverride<DefaultElementType>, "type"> & {
    as?: never;
    render?: never;
}) | Omit<AsOverride<any>, "type"> | (Omit<RenderOverride<DefaultElementType>, "type"> & {
    as?: never;
}) | React.ReactChild | null | undefined | (Partial<React.ComponentProps<DefaultElementType>> & {
    wrap?: never;
    wrapChildren?: never;
    props?: never;
    as?: never;
    render?: never;
}) | ((props: React.ComponentProps<DefaultElementType>) => React.ReactNode);
declare function hasVariant<V extends Variants>(variants: V | undefined, groupName: keyof V, variant: string): any;
declare function createPlasmicElementProxy<DefaultElementType extends React.ElementType>(defaultElement: DefaultElementType, props: Partial<React.ComponentProps<DefaultElementType>>, ...children: React.ReactNode[]): number | boolean | React.ReactElement<any, string | ((props: any) => React.ReactElement<any, any> | null) | (new (props: any) => React.Component<any, any, any>)> | React.ReactFragment | null | undefined;
declare function makeFragment(...children: React.ReactNode[]): React.FunctionComponentElement<{
    children?: React.ReactNode;
}>;
declare function wrapWithClassName(element: React.ReactNode, className: string): React.DetailedReactHTMLElement<{
    key: string | number | undefined;
    className: string;
    style: {
        display: "grid";
    };
}, HTMLElement>;
declare function mergeVariantsWithStates(variants: Variants, $state: $State, linkedStates: {
    variantGroup: string;
    statePath: (string | number)[];
}[]): Variants;
declare function deriveRenderOpts(props: Record<string, any>, config: {
    name: string;
    descendantNames: string[];
    internalVariantPropNames: string[];
    internalArgPropNames: string[];
}): {
    variants: Partial<Partial<Record<string, any>>>;
    args: Partial<Partial<Record<string, any>>>;
    overrides: Partial<Partial<Record<string, any>>>;
};

declare function ensureGlobalVariants<T extends Record<string, any>>(globalVariantValues: T): T;

declare type PlasmicHeadProps = {
    title?: string;
    description?: string;
    image?: string;
    canonical?: string;
};
declare function PlasmicHead(props: PlasmicHeadProps): JSX.Element | null;
declare const plasmicHeadMeta: {
    name: string;
    displayName: string;
    description: string;
    importName: string;
    importPath: string;
    isRepeatable: boolean;
    styleSections: boolean;
    props: {
        title: {
            type: string;
            displayName: string;
        };
        description: {
            type: string;
            displayName: string;
        };
        image: {
            type: string;
            displayName: string;
        };
        canonical: {
            type: string;
            displayName: string;
        };
    };
};

declare function PlasmicIcon(props: React.ComponentProps<"svg"> & {
    PlasmicIconType: React.ComponentType;
}): JSX.Element;

/**
 * Responsive `<img/>` replacement, based on `next/image`
 */

interface ImageLoader {
    supportsUrl: (url: string) => boolean;
    transformUrl: (opts: {
        src: string;
        width?: number;
        quality?: number;
        format?: "webp";
    }) => string;
}
declare type ImgTagProps = Omit<React__default.ComponentProps<"img">, "src" | "srcSet" | "ref" | "style">;
interface PlasmicImgProps extends ImgTagProps {
    /**
     * Either an object with the src string, and its full width and height,
     * or just a src string with unknown intrinsic dimensions.
     */
    src?: string | {
        src: string | {
            src: string;
            height: number;
            width: number;
            blurDataURL?: string;
        };
        fullHeight: number;
        fullWidth: number;
        aspectRatio?: number;
    };
    /**
     * className applied to the wrapper element if one is used.
     */
    className?: string;
    /**
     * css width
     */
    displayWidth?: number | string;
    /**
     * css height
     */
    displayHeight?: number | string;
    /**
     * css min-width
     */
    displayMinWidth?: number | string;
    /**
     * css min-height
     */
    displayMinHeight?: number | string;
    /**
     * css max-width
     */
    displayMaxWidth?: number | string;
    /**
     * css max-height
     */
    displayMaxHeight?: number | string;
    /**
     * For variable quality formats like jpg, the quality from 0 to 100
     */
    quality?: number;
    /**
     * ImageLoader to use for loading different dimensions of the image.
     * If none specified, will not attempt to load different dimensions.
     */
    loader?: "plasmic" | ImageLoader;
    /**
     * Style applied to the wrapper element. objectFit and objectPosition
     * rules are applied to the img element.
     */
    style?: React__default.CSSProperties;
    /**
     * Ref for the img element.  The normal <PlasmicImg ref={...} />
     * prop gives the root element instead, which may be the img element
     * or a wrapper element
     */
    imgRef?: React__default.Ref<HTMLImageElement>;
}
declare const PlasmicImg: React__default.ForwardRefExoticComponent<PlasmicImgProps & React__default.RefAttributes<HTMLElement>>;

declare const PlasmicLink: React__default.ForwardRefExoticComponent<Pick<any, string | number | symbol> & React__default.RefAttributes<any>>;

declare function PlasmicSlot<T extends keyof JSX.IntrinsicElements = "div">(props: React.ComponentProps<T> & {
    as?: T;
    defaultContents?: React.ReactNode;
    value?: React.ReactNode;
}): JSX.Element | null;
declare function renderPlasmicSlot<T extends keyof JSX.IntrinsicElements = "div">(opts: {
    as?: T;
    defaultContents?: React.ReactNode;
    value?: React.ReactNode;
}): JSX.Element | null;

declare type Queries = {
    [name: string]: string;
};
declare function createUseScreenVariants(isMulti: boolean, screenQueries: Queries): () => string | string[] | undefined;

/**
 * Returns whether the component is currently being server side rendered or
 * hydrated on the client. Can be used to delay browser-specific rendering
 * until after hydration.
 */
declare function useIsSSR$1(): boolean;

declare type PlasmicTranslator = (str: string, opts?: {
    components?: {
        [key: string]: React__default.ReactElement;
    };
}) => React__default.ReactNode;
interface TransProps {
    transKey?: string;
    children?: React__default.ReactNode;
}
declare function genTranslatableString(elt: React__default.ReactNode): {
    str: string;
    components: {
        [key: string]: React__default.ReactElement<any, string | ((props: any) => React__default.ReactElement<any, any> | null) | (new (props: any) => React__default.Component<any, any, any>)>;
    };
    componentsCount: number;
};
declare function Trans({ transKey, children }: TransProps): React__default.ReactNode;

interface PlasmicDataSourceContextValue {
    userAuthToken?: string;
    isUserLoading?: boolean;
    authRedirectUri?: string;
    user?: {
        email: string;
        properties: Record<string, unknown> | null;
        roleId: string;
        roleName: string;
        roleIds: string[];
        roleNames: string[];
    };
}
declare function useCurrentUser(): {
    email: string;
    properties: Record<string, unknown> | null;
    roleId: string;
    roleName: string;
    roleIds: string[];
    roleNames: string[];
} | undefined;
declare const PlasmicDataSourceContextProvider: React__default.Provider<PlasmicDataSourceContextValue | undefined>;

interface PlasmicRootProviderProps {
    platform?: "nextjs" | "gatsby";
    children?: React.ReactNode;
    translator?: PlasmicTranslator;
    Head?: React.ComponentType<any>;
}
declare function PlasmicRootProvider(props: PlasmicRootProviderProps): JSX.Element;
declare const useIsSSR: typeof useIsSSR$1;

declare const Stack: (<T extends "symbol" | "object" | "a" | "abbr" | "address" | "area" | "article" | "aside" | "audio" | "b" | "base" | "bdi" | "bdo" | "big" | "blockquote" | "body" | "br" | "button" | "canvas" | "caption" | "center" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dialog" | "div" | "dl" | "dt" | "em" | "embed" | "fieldset" | "figcaption" | "figure" | "footer" | "form" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "img" | "input" | "ins" | "kbd" | "keygen" | "label" | "legend" | "li" | "link" | "main" | "map" | "mark" | "menu" | "menuitem" | "meta" | "meter" | "nav" | "noindex" | "noscript" | "ol" | "optgroup" | "option" | "output" | "p" | "param" | "picture" | "pre" | "progress" | "q" | "rp" | "rt" | "ruby" | "s" | "samp" | "slot" | "script" | "section" | "select" | "small" | "source" | "span" | "strong" | "style" | "sub" | "summary" | "sup" | "table" | "template" | "tbody" | "td" | "textarea" | "tfoot" | "th" | "thead" | "time" | "title" | "tr" | "track" | "u" | "ul" | "var" | "video" | "wbr" | "webview" | "svg" | "animate" | "animateMotion" | "animateTransform" | "circle" | "clipPath" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "filter" | "foreignObject" | "g" | "image" | "line" | "linearGradient" | "marker" | "mask" | "metadata" | "mpath" | "path" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "stop" | "switch" | "text" | "textPath" | "tspan" | "use" | "view" = "div">(props: {
    as?: T | undefined;
    hasGap?: boolean | undefined;
} & React.ComponentProps<T>) => React.ReactElement) & {
    div: React.FC<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        hasGap?: boolean | undefined;
    }>;
    a: React.FC<React.ClassAttributes<HTMLAnchorElement> & React.AnchorHTMLAttributes<HTMLAnchorElement> & {
        hasGap?: boolean | undefined;
    }>;
    button: React.FC<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & {
        hasGap?: boolean | undefined;
    }>;
    h1: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h2: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h3: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h4: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h5: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h6: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    label: React.FC<React.ClassAttributes<HTMLLabelElement> & React.LabelHTMLAttributes<HTMLLabelElement> & {
        hasGap?: boolean | undefined;
    }>;
    form: React.FC<React.ClassAttributes<HTMLFormElement> & React.FormHTMLAttributes<HTMLFormElement> & {
        hasGap?: boolean | undefined;
    }>;
    section: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
    head: React.FC<React.ClassAttributes<HTMLHeadElement> & React.HTMLAttributes<HTMLHeadElement> & {
        hasGap?: boolean | undefined;
    }>;
    main: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
    nav: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
};

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


interface AriaLabelingProps {
  /**
   * Defines a string value that labels the current element.
   */
  'aria-label'?: string,

  /**
   * Identifies the element (or elements) that labels the current element.
   */
  'aria-labelledby'?: string,

  /**
   * Identifies the element (or elements) that describes the object.
   */
  'aria-describedby'?: string,

  /**
   * Identifies the element (or elements) that provide a detailed, extended description for the object.
   */
  'aria-details'?: string
}

interface AriaValidationProps {
  // https://www.w3.org/TR/wai-aria-1.2/#aria-errormessage
  /**
   * Identifies the element that provides an error message for the object.
   */
  'aria-errormessage'?: string
}

// A set of common DOM props that are allowed on any component
// Ensure this is synced with DOMPropNames in filterDOMProps
interface DOMProps {
  /**
   * The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id).
   */
  id?: string
}

interface FocusableDOMProps extends DOMProps {
  /**
   * Whether to exclude the element from the sequential tab order. If true,
   * the element will not be focusable via the keyboard by tabbing. This should
   * be avoided except in rare scenarios where an alternative means of accessing
   * the element or its functionality via the keyboard is available.
   */
  excludeFromTabOrder?: boolean
}

/** Any focusable element, including both HTML and SVG elements. */
interface FocusableElement extends Element, HTMLOrSVGElement {}

/** All DOM attributes supported across both HTML and SVG elements. */
interface DOMAttributes<T = FocusableElement> extends AriaAttributes, DOMAttributes$1<T> {
  id?: string | undefined,
  role?: AriaRole | undefined,
  tabIndex?: number | undefined,
  style?: CSSProperties | undefined,
  className?: string | undefined
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


type ValidationState = 'valid' | 'invalid';

interface Validation {
  /** Whether the input should display its "valid" or "invalid" visual styling. */
  validationState?: ValidationState,
  /**
   * Whether user input is required on the input before form submission.
   * Often paired with the `necessityIndicator` prop to add a visual indicator to the input.
   */
  isRequired?: boolean
}

interface InputBase {
  /** Whether the input is disabled. */
  isDisabled?: boolean,
  /** Whether the input can be selected but not changed by the user. */
  isReadOnly?: boolean
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


type SelectionMode = 'none' | 'single' | 'multiple';
type SelectionBehavior = 'toggle' | 'replace';
type Selection = 'all' | Set<Key>;

type FocusStrategy = 'first' | 'last';
type DisabledBehavior = 'selection' | 'all';

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


/**
 * A generic interface to access a readonly sequential
 * collection of unique keyed items.
 */
interface Collection<T> extends Iterable<T> {
  /** The number of items in the collection. */
  readonly size: number,

  /** Iterate over all keys in the collection. */
  getKeys(): Iterable<Key>,

  /** Get an item by its key. */
  getItem(key: Key): T,

  /** Get an item by the index of its key. */
  at(idx: number): T,

  /** Get the key that comes before the given key in the collection. */
  getKeyBefore(key: Key): Key | null,

  /** Get the key that comes after the given key in the collection. */
  getKeyAfter(key: Key): Key | null,

  /** Get the first key in the collection. */
  getFirstKey(): Key | null,

  /** Get the last key in the collection. */
  getLastKey(): Key | null
}

interface Node<T> {
  /** The type of item this node represents. */
  type: string,
  /** A unique key for the node. */
  key: Key,
  /** The object value the node was created from. */
  value: T,
  /** The level of depth this node is at in the heirarchy. */
  level: number,
  /** Whether this item has children, even if not loaded yet. */
  hasChildNodes: boolean,
  /** The loaded children of this node. */
  childNodes: Iterable<Node<T>>,
  /** The rendered contents of this node (e.g. JSX). */
  rendered: ReactNode,
  /** A string value for this node, used for features like typeahead. */
  textValue: string,
  /** An accessibility label for this node. */
  'aria-label'?: string,
  /** The index of this node within its parent. */
  index?: number,
  /** A function that should be called to wrap the rendered node. */
  wrapper?: (element: ReactElement) => ReactElement,
  /** The key of the parent node. */
  parentKey?: Key,
  /** The key of the node before this node. */
  prevKey?: Key,
  /** The key of the node after this node. */
  nextKey?: Key,
  /** Additional properties specific to a particular node type. */
  props?: any,
  /** @private */
  shouldInvalidate?: (context: unknown) => boolean
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


// Event bubbling can be problematic in real-world applications, so the default for React Spectrum components
// is not to propagate. This can be overridden by calling continuePropagation() on the event.
type BaseEvent<T extends SyntheticEvent> = T & {
  /** @deprecated Use continuePropagation. */
  stopPropagation(): void,
  continuePropagation(): void
}

type KeyboardEvent = BaseEvent<KeyboardEvent$1<any>>;

type PointerType = 'mouse' | 'pen' | 'touch' | 'keyboard' | 'virtual';

interface PressEvent {
  /** The type of press event being fired. */
  type: 'pressstart' | 'pressend' | 'pressup' | 'press',
  /** The pointer type that triggered the press event. */
  pointerType: PointerType,
  /** The target element of the press event. */
  target: Element,
  /** Whether the shift keyboard modifier was held during the press event. */
  shiftKey: boolean,
  /** Whether the ctrl keyboard modifier was held during the press event. */
  ctrlKey: boolean,
  /** Whether the meta keyboard modifier was held during the press event. */
  metaKey: boolean,
  /** Whether the alt keyboard modifier was held during the press event. */
  altKey: boolean
}

interface LongPressEvent extends Omit<PressEvent, 'type'> {
  /** The type of long press event being fired. */
  type: 'longpressstart' | 'longpressend' | 'longpress'
}

interface KeyboardEvents {
  /** Handler that is called when a key is pressed. */
  onKeyDown?: (e: KeyboardEvent) => void,
  /** Handler that is called when a key is released. */
  onKeyUp?: (e: KeyboardEvent) => void
}

interface FocusEvents {
  /** Handler that is called when the element receives focus. */
  onFocus?: (e: FocusEvent) => void,
  /** Handler that is called when the element loses focus. */
  onBlur?: (e: FocusEvent) => void,
  /** Handler that is called when the element's focus status changes. */
  onFocusChange?: (isFocused: boolean) => void
}

interface FocusableProps extends FocusEvents, KeyboardEvents {
  /** Whether the element should receive focus on render. */
  autoFocus?: boolean
}

declare function useFocused(opts: {
    isTextInput?: boolean;
}): (boolean | DOMAttributes<FocusableElement>)[];
declare function useFocusVisible(opts: {
    isTextInput?: boolean;
}): (boolean | DOMAttributes<FocusableElement>)[];
declare function useFocusedWithin(opts: {
    isTextInput?: boolean;
}): (boolean | DOMAttributes<FocusableElement>)[];
declare function useFocusVisibleWithin(opts: {
    isTextInput?: boolean;
}): (boolean | DOMAttributes<FocusableElement>)[];
declare function useHover(): (boolean | {
    onMouseEnter: () => void;
    onMouseLeave: () => void;
})[];
declare function usePressed(): (boolean | {
    onMouseDown: () => void;
    onMouseUp: () => void;
})[];
declare const TRIGGER_TO_HOOK: {
    readonly useHover: typeof useHover;
    readonly useFocused: typeof useFocused;
    readonly useFocusVisible: typeof useFocusVisible;
    readonly useFocusedWithin: typeof useFocusedWithin;
    readonly useFocusVisibleWithin: typeof useFocusVisibleWithin;
    readonly usePressed: typeof usePressed;
};
declare type TriggerType = keyof typeof TRIGGER_TO_HOOK;
interface TriggerOpts {
    isTextInput?: boolean;
}
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */
declare function useTrigger(trigger: TriggerType, opts: TriggerOpts): [boolean, React.HTMLAttributes<HTMLElement>];

declare const classNames: typeof classNames$1;

declare function setPlumeStrictMode(mode: boolean): void;
declare type VariantArgChoices<T> = T extends (infer M)[] ? M : T extends SingleChoiceArg<infer M> ? M : never;
declare type VariantArgsChoices<V> = {
    [k in keyof V]-?: VariantArgChoices<V[k]>;
};
declare type DictValues<V extends Record<string, any>> = V[keyof V];
declare type DictTuples<V extends Record<string, any>> = DictValues<{
    [K in keyof V]: [K, V[K]];
}>;
declare type VariantDefTuple<V> = DictTuples<VariantArgsChoices<V>>;
declare type DistributeTuple<T> = T extends [infer T1, infer T2] ? {
    group: T1;
    variant: T2;
} : never;
declare type VariantDef<V> = DistributeTuple<VariantDefTuple<V>>;
declare type PlasmicClass<V extends Record<string, any>, A extends Record<string, any>, O extends Record<string, any>> = {
    (props: {
        variants?: V;
        args?: A;
        overrides?: O;
    }): React.ReactElement | null;
    internalVariantProps: (keyof V)[];
    internalArgProps: (keyof A)[];
};
declare type AnyPlasmicClass = PlasmicClass<any, any, any>;
declare type PlasmicClassVariants<C extends AnyPlasmicClass> = C extends PlasmicClass<infer V, any, any> ? V : unknown;
declare type PlasmicClassArgs<C extends AnyPlasmicClass> = C extends PlasmicClass<any, infer A, any> ? A : unknown;
declare type PlasmicClassOverrides<C extends AnyPlasmicClass> = C extends PlasmicClass<any, any, infer O> ? O : unknown;

interface CommonProps {
    showStartIcon?: boolean;
    showEndIcon?: boolean;
    startIcon?: React.ReactNode;
    endIcon?: React.ReactNode;
    children?: React.ReactNode;
    isDisabled?: boolean;
}
interface HtmlButtonProps extends Omit<React.ComponentProps<"button">, "ref" | "disabled"> {
}
interface HtmlAnchorProps extends Omit<React.ComponentProps<"a">, "ref" | "href"> {
    link?: string;
}
declare type BaseButtonProps = CommonProps & HtmlButtonProps & HtmlAnchorProps;
declare type HtmlAnchorOnlyProps = Exclude<keyof HtmlAnchorProps, keyof HtmlButtonProps>;
declare type HtmlButtonOnlyProps = Exclude<keyof HtmlButtonProps, keyof HtmlAnchorProps>;
declare type ButtonRef = React.Ref<HTMLButtonElement | HTMLAnchorElement>;
interface ButtonConfig<C extends AnyPlasmicClass> {
    showStartIconVariant: VariantDef<PlasmicClassVariants<C>>;
    showEndIconVariant?: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    startIconSlot?: keyof PlasmicClassArgs<C>;
    endIconSlot?: keyof PlasmicClassArgs<C>;
    contentSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
}
declare function useButton<P extends BaseButtonProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: ButtonConfig<C>, ref?: ButtonRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


interface ToggleProps extends InputBase, Validation, FocusableProps {
  /**
   * The label for the element.
   */
  children?: ReactNode,
  /**
   * Whether the element should be selected (uncontrolled).
   */
  defaultSelected?: boolean,
  /**
   * Whether the element should be selected (controlled).
   */
  isSelected?: boolean,
  /**
   * Handler that is called when the element's selection state changes.
   */
  onChange?: (isSelected: boolean) => void,
  /**
   * The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue).
   */
  value?: string,
  /**
   * The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).
   */
  name?: string
}

interface AriaToggleProps extends ToggleProps, FocusableDOMProps, AriaLabelingProps, AriaValidationProps {
  /**
   * Identifies the element (or elements) whose contents or presence are controlled by the current element.
   */
  'aria-controls'?: string
}

interface CheckboxProps$1 extends ToggleProps {
  /**
   * Indeterminism is presentational only.
   * The indeterminate visual representation remains regardless of user interaction.
   */
  isIndeterminate?: boolean
}

interface AriaCheckboxProps extends CheckboxProps$1, AriaToggleProps {}

interface StyleProps {
    className?: string;
    style?: React.CSSProperties;
}
declare function getDataProps(props: Record<string, any>): Partial<Record<string, any>>;

declare type CheckboxRef = React.Ref<CheckboxRefValue>;
interface CheckboxRefValue extends CheckboxState {
    getRoot: () => HTMLElement | null;
    focus: () => void;
    blur: () => void;
}
interface CheckboxState {
    setChecked: (checked: boolean) => void;
}
interface CheckboxProps extends Omit<AriaCheckboxProps, "isSelected" | "defaultSelected">, StyleProps {
    /**
     * Whether the Checkbox is checked or not; controlled
     */
    isChecked?: boolean;
    /**
     * Whether the Checkbox is checked by default; uncontrolled
     */
    defaultChecked?: boolean;
    /**
     * Whether the Checkbox is in an "indeterminate" state; this usually
     * refers to a "check all" that is used to check / uncheck many other
     * checkboxes, and is visually indeterminate if some of its controlled
     * checkboxes are checked and some are not.
     */
    isIndeterminate?: boolean;
}
interface CheckboxConfig<C extends AnyPlasmicClass> {
    isCheckedVariant: VariantDef<PlasmicClassVariants<C>>;
    isIndeterminateVariant?: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    noLabelVariant?: VariantDef<PlasmicClassVariants<C>>;
    labelSlot?: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
}
declare function useCheckbox<P extends CheckboxProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: CheckboxConfig<C>, ref?: CheckboxRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        overrides: PlasmicClassOverrides<C>;
        args: PlasmicClassArgs<C>;
    };
    state: CheckboxState;
};

interface BaseMenuProps extends DOMProps, AriaLabelingProps, StyleProps {
    /**
     * List of `Menu.Item`s or `Menu.Group`s that make up the menu
     */
    children?: React.ReactNode;
    /**
     * Called with the value of a `Menu.Item` when it is selected.
     */
    onAction?: (value: string) => void;
}
declare type MenuRef = React.Ref<MenuRefValue>;
interface MenuRefValue extends MenuState {
    getRoot: () => HTMLElement | null;
}
interface MenuConfig<C extends AnyPlasmicClass> {
    isPlacedTopVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedBottomVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedLeftVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedRightVariant?: VariantDef<PlasmicClassVariants<C>>;
    itemsSlot: keyof PlasmicClassArgs<C>;
    itemsContainer: keyof PlasmicClassOverrides<C>;
    root: keyof PlasmicClassOverrides<C>;
}
interface MenuState {
    getFocusedValue: () => string | null;
    setFocusedValue: (value: string) => void;
}
declare function useMenu<P extends BaseMenuProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: MenuConfig<C>, ref?: MenuRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
    state: MenuState;
};

/**
 * In general, we try not to expose react-aria's Collections API to Plume users.
 * The Collections API is how react-aria users pass data about collections of
 * things using the built-in Item and Section components, which are abstract,
 * metadata-only components that don't render anything but only serve to specify
 * data.  For example, here's how you would use react-spectrum's Picker:
 *
 *   <Picker>
 *     <Section title="Asia">
 *       <Item key="taiwan">Taiwan</Item>
 *       <Item key="japan">Japan</Item>
 *       <Item key="china">China</Item>
 *     </Section>
 *     <Section title="Europe">
 *       <Item key="germany">Germany</Item>
 *       <Item key="france">France</Item>
 *     </Section>
 *   </Picker>
 *
 * You would re-use this same Item/Section components to pass similar things to
 * Menu, Tabs, etc.
 *
 * For Plasmic, this API is too abstract.  The user has explicitly designed components
 * like Select.Option and Select.OptionGroup, and it is weird that they don't actually
 * use these components. It is more natural to do:
 *
 *   <Select>
 *     <Select.OptionGroup title="Asia">
 *       <Select.Option key="taiwan">Taiwan</Select>
 *     </Select.OptionGroup>
 *   </Select>
 *
 * For Plume, we let users directly use the components they designed, both to collect
 * information and to perform actual rendering.  For example, for Plume,
 * you'd use Select.Option instead of Item, and Select.OptionGroup instead of Section.
 * This means that the Select.Option props will collect the same information Item
 * does.
 *
 * A component like Select.Option then serves two purposes:
 *
 * 1. Allow users to specify the collection of data, like in the above example
 *    Here, we're mainly interested in the props in those ReactElements so
 *    we can pass the Item/Section data onto react-aria's APIs.  We are not
 *    actually rendering these elements.
 * 2. Once react-aria's Collections API has gone through them and built
 *    Collection "nodes", we then create cloned versions of these elements
 *    with the corresponding node passed in as a secret prop.  These ReactElements
 *    are then actually used to _render_ the corresponding Option / OptionGroup.
 *
 * This file contains helper functions to help with implementing the above.
 *
 * Note also that most of the collections-based react-aria components expose
 * a parallel API that accepts a list of "items" and a render prop, instead
 * of list of Item/Section elements.  This is for efficiency, but we are opting
 * to only support the composite-component pattern for now for simplicity.
 */

/**
 * Props for a Plume component that corresponds to an Item
 */
interface ItemLikeProps {
    /**
     * value key corresponding to this item. Not required if you use the
     * `key` prop instead.
     */
    value?: string | null;
    /**
     * The text string value corresponding to this item. Used to support
     * keyboard type-ahead.  If not specified, then will be derived from
     * `children` if it is a string, or the `value` or `key`.
     */
    textValue?: string;
    /**
     * aria-label for this item.
     */
    "aria-label"?: string;
    /**
     * Primary content label for this item.
     */
    children?: React__default.ReactNode;
    /**
     * If true, this item will not be selectable.
     */
    isDisabled?: boolean;
}
/**
 * Props for a Plume component that corresponds to a Section
 */
interface SectionLikeProps {
    /**
     * Heading content of the title
     */
    title?: React__default.ReactNode;
    /**
     * aria-label for this section
     */
    "aria-label"?: string;
    /**
     * A list of items that belong in this group
     */
    children?: React__default.ReactNode;
}
declare type ItemJson = LeafItemJson | SectionJson;
declare type LeafItemJson = string | {
    value: string;
    label?: string;
    textValue?: string;
    isDisabled?: boolean;
};
interface SectionJson {
    title: string;
    children: ItemJson[];
}

interface BaseMenuGroupProps extends SectionLikeProps, StyleProps {
}
interface MenuGroupConfig<C extends AnyPlasmicClass> {
    noTitleVariant: PlasmicClassVariants<C>;
    isFirstVariant: PlasmicClassVariants<C>;
    itemsSlot: keyof PlasmicClassArgs<C>;
    titleSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    separator: keyof PlasmicClassOverrides<C>;
    titleContainer: keyof PlasmicClassOverrides<C>;
    itemsContainer: keyof PlasmicClassOverrides<C>;
}
declare function useMenuGroup<P extends BaseMenuGroupProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: MenuGroupConfig<C>): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

interface BaseMenuItemProps extends ItemLikeProps {
    /**
     * Called when this item is selected
     */
    onAction?: (key: string) => void;
}
interface MenuItemConfig<C extends AnyPlasmicClass> {
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    isHighlightedVariant?: VariantDef<PlasmicClassVariants<C>>;
    labelSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    labelContainer: keyof PlasmicClassOverrides<C>;
}
declare function useMenuItem<P extends BaseMenuItemProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: MenuItemConfig<C>): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


type Placement = 'bottom' | 'bottom left' | 'bottom right' | 'bottom start' | 'bottom end' |
    'top' | 'top left' | 'top right' | 'top start' | 'top end' |
    'left' | 'left top' | 'left bottom' | 'start' | 'start top' | 'start bottom' |
    'right' | 'right top' | 'right bottom' | 'end' | 'end top' | 'end bottom';

interface DropdownMenuProps {
    /**
     * A ReactElement that takes in a `ref` as well as the usual mouse and
     * pointer events. The dropdown menu will be positioned relative to this
     * trigger.
     */
    children: React.ReactElement;
    /**
     * The menu to show; must be either a ReactElement of Menu type, or
     * a function that creates one if you prefer to delay creating it until
     * the menu has been triggered.
     */
    menu: React.ReactElement<BaseMenuProps> | (() => React.ReactElement<BaseMenuProps>);
    /**
     * Where to place the menu relative to the trigger.
     */
    placement?: Placement;
    /**
     * Whether the menu is currently shown.
     */
    isOpen?: boolean;
    /**
     * Uncontrolled open state.
     */
    defaultOpen?: boolean;
    /**
     * Event handler fired when Menu's open state changes
     */
    onOpenChange?: (isOpen: boolean) => void;
}
declare function DropdownMenu(props: DropdownMenuProps): JSX.Element;

interface BaseMenuButtonProps extends DOMProps, FocusableProps, StyleProps, Pick<React.ComponentProps<"button">, "title"> {
    /**
     * The menu to show; can either be a Menu instance, or a function that returns a Menu
     * instance if you want to defer creating the instance till when it's opened.
     */
    menu: React.ReactElement<BaseMenuProps> | (() => React.ReactElement<BaseMenuProps>);
    /**
     * Whether the button is disabled
     */
    isDisabled?: boolean;
    /**
     * Whether the menu is currently shown.
     */
    isOpen?: boolean;
    /**
     * Uncontrolled open state
     */
    defaultOpen?: boolean;
    /**
     * Event handler fired when Menu's open state changes
     */
    onOpenChange?: (isOpen: boolean) => void;
    /**
     * Desired placement location of the Select dropdown
     */
    placement?: Placement;
    /**
     * If true, menu width will always match the trigger button width.
     * If false, then menu width will have min-width matching the
     * trigger button width.
     */
    menuMatchTriggerWidth?: boolean;
    /**
     * If set, menu width will be exactly this width, overriding
     * menuMatchTriggerWidth.
     */
    menuWidth?: number;
}
interface MenuButtonConfig<C extends AnyPlasmicClass> {
    isOpenVariant: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    menuSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    trigger: keyof PlasmicClassOverrides<C>;
}
interface MenuButtonState {
    open: () => void;
    close: () => void;
    isOpen: () => boolean;
}
declare type MenuButtonRef = React.Ref<MenuButtonRefValue>;
interface MenuButtonRefValue extends MenuButtonState {
    getRoot: () => HTMLElement | null;
    getTrigger: () => HTMLElement | null;
    focus: () => void;
    blur: () => void;
}
declare function useMenuButton<P extends BaseMenuButtonProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: MenuButtonConfig<C>, outerRef?: MenuButtonRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
    state: MenuButtonState;
};

interface BaseSelectProps extends DOMProps, AriaLabelingProps, FocusableDOMProps, InputBase, FocusableProps, StyleProps {
    /**
     * Key of the currently selected value
     */
    value?: string | null;
    /**
     * Event handler fired when currently selected value changes
     */
    onChange?: (value: string | null) => void;
    /**
     * Uncontrolled key of the default selected value
     */
    defaultValue?: string;
    /**
     * List of Select.Options
     */
    children?: React.ReactNode;
    /**
     * List of options as an array, instead of using `children` prop. If this
     * is passed in, then `children` is ignored.
     *
     * The options can be a list of strings, or a list of objects with
     * fields `value` (for the value of the option), `label` (for what's rendered
     * in the option), and `isDisabled` (if the option should be disabled).
     */
    options?: ItemJson[];
    /**
     * Whether the Select is currently open
     */
    isOpen?: boolean;
    /**
     * Event handler fired when Select's open state changes
     */
    onOpenChange?: (isOpen: boolean) => void;
    /**
     * Uncontrolled default open state
     */
    defaultOpen?: boolean;
    /**
     * Form name of the select element
     */
    name?: string;
    /**
     * By default, Select will render whatever is in Select.Option as the
     * content in the trigger button when it is selected.  You can override
     * what content by passing in `selectedContent` here.
     */
    selectedContent?: React.ReactNode;
    /**
     * Desired placement location of the Select dropdown
     */
    placement?: Placement;
    /**
     * If true, menu width will always match the trigger button width.
     * If false, then menu width will have min-width matching the
     * trigger button width.
     */
    menuMatchTriggerWidth?: boolean;
    /**
     * If set, menu width will be exactly this width, overriding
     * menuMatchTriggerWidth.
     */
    menuWidth?: number;
    /**
     * Content to display when nothing is selected.
     */
    placeholder?: React.ReactNode;
}
declare type SelectRef = React.Ref<SelectRefValue>;
interface SelectRefValue extends SelectState {
    getTrigger: () => HTMLElement | null;
    getRoot: () => HTMLElement | null;
    focus: () => void;
    blur: () => void;
}
interface SelectConfig<C extends AnyPlasmicClass> {
    placeholderVariant?: VariantDef<PlasmicClassVariants<C>>;
    isOpenVariant: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    triggerContentSlot: keyof PlasmicClassArgs<C>;
    optionsSlot: keyof PlasmicClassArgs<C>;
    placeholderSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    trigger: keyof PlasmicClassOverrides<C>;
    overlay: keyof PlasmicClassOverrides<C>;
    optionsContainer: keyof PlasmicClassOverrides<C>;
    OptionComponent?: React.ComponentType<ItemLikeProps>;
    OptionGroupComponent?: React.ComponentType<SectionLikeProps>;
}
interface SelectState {
    open: () => void;
    close: () => void;
    isOpen: () => boolean;
    getSelectedValue: () => string | null;
    setSelectedValue: (value: string | null) => void;
}
declare function useSelect<P extends BaseSelectProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: SelectConfig<C>, ref?: React.Ref<SelectRefValue>): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
    state: SelectState;
};

interface BaseSelectOptionProps extends ItemLikeProps, StyleProps {
}
interface SelectOptionConfig<C extends AnyPlasmicClass> {
    isSelectedVariant: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    isHighlightedVariant?: VariantDef<PlasmicClassVariants<C>>;
    labelSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    labelContainer: keyof PlasmicClassOverrides<C>;
}
declare type SelectOptionRef = React.Ref<HTMLElement>;
declare function useSelectOption<P extends BaseSelectOptionProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: SelectOptionConfig<C>, outerRef?: SelectOptionRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

interface BaseSelectOptionGroupProps extends SectionLikeProps, StyleProps {
}
interface SelectOptionGroupConfig<C extends AnyPlasmicClass> {
    noTitleVariant: PlasmicClassVariants<C>;
    isFirstVariant: PlasmicClassVariants<C>;
    optionsSlot: keyof PlasmicClassArgs<C>;
    titleSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    separator: keyof PlasmicClassOverrides<C>;
    titleContainer: keyof PlasmicClassOverrides<C>;
    optionsContainer: keyof PlasmicClassOverrides<C>;
}
declare function useSelectOptionGroup<P extends BaseSelectOptionGroupProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: SelectOptionGroupConfig<C>): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

interface FocusState {
    /** Whether the collection is currently focused. */
    readonly isFocused: boolean;
    /** Sets whether the collection is focused. */
    setFocused(isFocused: boolean): void;
    /** The current focused key in the collection. */
    readonly focusedKey: Key;
    /** Whether the first or last child of the focused key should receive focus. */
    readonly childFocusStrategy: FocusStrategy;
    /** Sets the focused key, and optionally, whether the first or last child of that key should receive focus. */
    setFocusedKey(key: Key, child?: FocusStrategy): void;
}
interface MultipleSelectionState extends FocusState {
    /** The type of selection that is allowed in the collection. */
    readonly selectionMode: SelectionMode;
    /** The selection behavior for the collection. */
    readonly selectionBehavior: SelectionBehavior;
    /** Sets the selection behavior for the collection. */
    setSelectionBehavior(selectionBehavior: SelectionBehavior): void;
    /** Whether the collection allows empty selection. */
    readonly disallowEmptySelection: boolean;
    /** The currently selected keys in the collection. */
    readonly selectedKeys: Selection;
    /** Sets the selected keys in the collection. */
    setSelectedKeys(keys: Selection): void;
    /** The currently disabled keys in the collection. */
    readonly disabledKeys: Set<Key>;
    /** Whether `disabledKeys` applies to selection, actions, or both. */
    readonly disabledBehavior: DisabledBehavior;
}
interface MultipleSelectionManager extends FocusState {
    /** The type of selection that is allowed in the collection. */
    readonly selectionMode: SelectionMode;
    /** The selection behavior for the collection. */
    readonly selectionBehavior: SelectionBehavior;
    /** Whether the collection allows empty selection. */
    readonly disallowEmptySelection?: boolean;
    /** The currently selected keys in the collection. */
    readonly selectedKeys: Set<Key>;
    /** Whether the selection is empty. */
    readonly isEmpty: boolean;
    /** Whether all items in the collection are selected. */
    readonly isSelectAll: boolean;
    /** The first selected key in the collection. */
    readonly firstSelectedKey: Key | null;
    /** The last selected key in the collection. */
    readonly lastSelectedKey: Key | null;
    /** The currently disabled keys in the collection. */
    readonly disabledKeys: Set<Key>;
    /** Whether `disabledKeys` applies to selection, actions, or both. */
    readonly disabledBehavior: DisabledBehavior;
    /** Returns whether a key is selected. */
    isSelected(key: Key): boolean;
    /** Returns whether the current selection is equal to the given selection. */
    isSelectionEqual(selection: Set<Key>): boolean;
    /** Extends the selection to the given key. */
    extendSelection(toKey: Key): void;
    /** Toggles whether the given key is selected. */
    toggleSelection(key: Key): void;
    /** Replaces the selection with only the given key. */
    replaceSelection(key: Key): void;
    /** Replaces the selection with the given keys. */
    setSelectedKeys(keys: Iterable<Key>): void;
    /** Selects all items in the collection. */
    selectAll(): void;
    /** Removes all keys from the selection. */
    clearSelection(): void;
    /** Toggles between select all and an empty selection. */
    toggleSelectAll(): void;
    /**
     * Toggles, replaces, or extends selection to the given key depending
     * on the pointer event and collection's selection mode.
     */
    select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent): void;
    /** Returns whether the given key can be selected. */
    canSelectItem(key: Key): boolean;
    /** Returns whether the given key is non-interactive, i.e. both selection and actions are disabled. */
    isDisabled(key: Key): boolean;
    /** Sets the selection behavior for the collection. */
    setSelectionBehavior(selectionBehavior: SelectionBehavior): void;
}
interface SelectionManagerOptions {
    allowsCellSelection?: boolean;
}
/**
 * An interface for reading and updating multiple selection state.
 */
declare class SelectionManager implements MultipleSelectionManager {
    constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions);
    /**
     * The type of selection that is allowed in the collection.
     */
    get selectionMode(): SelectionMode;
    /**
     * Whether the collection allows empty selection.
     */
    get disallowEmptySelection(): boolean;
    /**
     * The selection behavior for the collection.
     */
    get selectionBehavior(): SelectionBehavior;
    /**
     * Sets the selection behavior for the collection.
     */
    setSelectionBehavior(selectionBehavior: SelectionBehavior): void;
    /**
     * Whether the collection is currently focused.
     */
    get isFocused(): boolean;
    /**
     * Sets whether the collection is focused.
     */
    setFocused(isFocused: boolean): void;
    /**
     * The current focused key in the collection.
     */
    get focusedKey(): Key;
    /** Whether the first or last child of the focused key should receive focus. */
    get childFocusStrategy(): FocusStrategy;
    /**
     * Sets the focused key.
     */
    setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy): void;
    /**
     * The currently selected keys in the collection.
     */
    get selectedKeys(): Set<Key>;
    /**
     * The raw selection value for the collection.
     * Either 'all' for select all, or a set of keys.
     */
    get rawSelection(): Selection;
    /**
     * Returns whether a key is selected.
     */
    isSelected(key: Key): boolean;
    /**
     * Whether the selection is empty.
     */
    get isEmpty(): boolean;
    /**
     * Whether all items in the collection are selected.
     */
    get isSelectAll(): boolean;
    get firstSelectedKey(): Key | null;
    get lastSelectedKey(): Key | null;
    get disabledKeys(): Set<Key>;
    get disabledBehavior(): DisabledBehavior;
    /**
     * Extends the selection to the given key.
     */
    extendSelection(toKey: Key): void;
    /**
     * Toggles whether the given key is selected.
     */
    toggleSelection(key: Key): void;
    /**
     * Replaces the selection with only the given key.
     */
    replaceSelection(key: Key): void;
    /**
     * Replaces the selection with the given keys.
     */
    setSelectedKeys(keys: Iterable<Key>): void;
    /**
     * Selects all items in the collection.
     */
    selectAll(): void;
    /**
     * Removes all keys from the selection.
     */
    clearSelection(): void;
    /**
     * Toggles between select all and an empty selection.
     */
    toggleSelectAll(): void;
    select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent): void;
    /**
     * Returns whether the current selection is equal to the given selection.
     */
    isSelectionEqual(selection: Set<Key>): boolean;
    canSelectItem(key: Key): boolean;
    isDisabled(key: Key): boolean;
}

interface ListState<T> {
    /** A collection of items in the list. */
    collection: Collection<Node<T>>;
    /** A set of items that are disabled. */
    disabledKeys: Set<Key>;
    /** A selection manager to read and update multiple selection state. */
    selectionManager: SelectionManager;
}

declare const SelectContext: React.Context<ListState<any> | undefined>;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */


interface SwitchBase extends InputBase, FocusableProps {
  /**
   * The content to render as the Switch's label.
   */
  children?: ReactNode,
  /**
   * Whether the Switch should be selected (uncontrolled).
   */
  defaultSelected?: boolean,
  /**
   * Whether the Switch should be selected (controlled).
   */
  isSelected?: boolean,
  /**
   * Handler that is called when the Switch's selection state changes.
   */
  onChange?: (isSelected: boolean) => void,
  /**
   * The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue).
   */
  value?: string,
  /**
   * The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).
   */
  name?: string
}
interface SwitchProps$1 extends SwitchBase {}
interface AriaSwitchBase extends SwitchBase, FocusableDOMProps, AriaLabelingProps {
  /**
   * Identifies the element (or elements) whose contents or presence are controlled by the current element.
   */
  'aria-controls'?: string
}
interface AriaSwitchProps extends SwitchProps$1, AriaSwitchBase {}

declare type SwitchRef = React.Ref<SwitchRefValue>;
interface SwitchRefValue extends SwitchState {
    getRoot: () => HTMLElement | null;
    focus: () => void;
    blur: () => void;
}
interface SwitchState {
    setChecked: (checked: boolean) => void;
}
interface SwitchProps extends Omit<AriaSwitchProps, "isSelected" | "defaultSelected">, StyleProps {
    /**
     * Whether the Switch is checked or not; controlled
     */
    isChecked?: boolean;
    /**
     * Whether the Switch is checked by default; uncontrolled
     */
    defaultChecked?: boolean;
}
interface SwitchConfig<C extends AnyPlasmicClass> {
    isCheckedVariant: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    noLabelVariant?: VariantDef<PlasmicClassVariants<C>>;
    labelSlot?: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
}
declare function useSwitch<P extends SwitchProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: SwitchConfig<C>, ref?: SwitchRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        overrides: PlasmicClassOverrides<C>;
        args: PlasmicClassArgs<C>;
    };
    state: SwitchState;
};

interface BaseTextInputProps extends Omit<React.ComponentProps<"input">, "type" | "disabled"> {
    showStartIcon?: boolean;
    showEndIcon?: boolean;
    startIcon?: React.ReactNode;
    endIcon?: React.ReactNode;
    isDisabled?: boolean;
    type?: "text" | "password" | "email" | "url" | string;
    inputClassName?: string;
    inputStyle?: React.CSSProperties;
}
interface TextInputRefValue {
    focus: () => void;
    blur: () => void;
    getRoot: () => HTMLElement | null;
    getInput: () => HTMLInputElement | null;
}
declare type TextInputRef = React.Ref<TextInputRefValue>;
interface TextInputConfig<C extends AnyPlasmicClass> {
    showStartIconVariant: VariantDef<PlasmicClassVariants<C>>;
    showEndIconVariant?: VariantDef<PlasmicClassVariants<C>>;
    isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;
    startIconSlot?: keyof PlasmicClassArgs<C>;
    endIconSlot?: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    input: keyof PlasmicClassOverrides<C>;
}
declare function useTextInput<P extends BaseTextInputProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: TextInputConfig<C>, ref?: TextInputRef): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

interface BaseTriggeredOverlayProps extends StyleProps, DOMProps {
    children?: React.ReactNode;
}
interface TriggeredOverlayConfig<C extends AnyPlasmicClass> {
    isPlacedTopVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedBottomVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedLeftVariant?: VariantDef<PlasmicClassVariants<C>>;
    isPlacedRightVariant?: VariantDef<PlasmicClassVariants<C>>;
    contentSlot: keyof PlasmicClassArgs<C>;
    root: keyof PlasmicClassOverrides<C>;
    contentContainer: keyof PlasmicClassOverrides<C>;
}
declare type TriggeredOverlayRef = React.Ref<HTMLElement>;
declare function useTriggeredOverlay<P extends BaseTriggeredOverlayProps, C extends AnyPlasmicClass>(plasmicClass: C, props: P, config: TriggeredOverlayConfig<C>, outerRef?: TriggeredOverlayRef, isDismissable?: boolean): {
    plasmicProps: {
        variants: PlasmicClassVariants<C>;
        args: PlasmicClassArgs<C>;
        overrides: PlasmicClassOverrides<C>;
    };
};

interface OverlayTriggerState {
    /** Whether the overlay is currently open. */
    readonly isOpen: boolean;
    /** Sets whether the overlay is open. */
    setOpen(isOpen: boolean): void;
    /** Opens the overlay. */
    open(): void;
    /** Closes the overlay. */
    close(): void;
    /** Toggles the overlay's visibility. */
    toggle(): void;
}

interface TriggeredOverlayContextValue {
    triggerRef: React.RefObject<HTMLElement>;
    state: OverlayTriggerState;
    autoFocus?: boolean | FocusStrategy;
    placement?: Placement;
    overlayMatchTriggerWidth?: boolean;
    overlayMinTriggerWidth?: boolean;
    overlayWidth?: number;
}
declare const TriggeredOverlayContext: React.Context<TriggeredOverlayContextValue | undefined>;

export { $State, $StateSpec, BaseButtonProps, BaseMenuButtonProps, BaseMenuGroupProps, BaseMenuItemProps, BaseMenuProps, BaseSelectOptionGroupProps, BaseSelectOptionProps, BaseSelectProps, BaseTextInputProps, BaseTriggeredOverlayProps, ButtonRef, CheckboxProps, CheckboxRef, CheckboxRefValue, DropdownMenu, Flex, HTMLElementRefOf, HtmlAnchorOnlyProps, HtmlButtonOnlyProps, MenuButtonRef, MenuButtonRefValue, MenuRef, MenuRefValue, MultiChoiceArg, PlasmicDataSourceContextProvider, PlasmicHead, PlasmicIcon, PlasmicImg, PlasmicLink, PlasmicPageGuard, PlasmicRootProvider, PlasmicSlot, SelectContext, SelectOptionRef, SelectRef, SelectRefValue, SingleBooleanChoiceArg, SingleChoiceArg, Stack, StrictProps, SwitchProps, SwitchRef, SwitchRefValue, TextInputRef, TextInputRefValue, Trans, TriggeredOverlayConfig, TriggeredOverlayContext, TriggeredOverlayRef, classNames, createPlasmicElementProxy, createUseScreenVariants, deriveRenderOpts, ensureGlobalVariants, genTranslatableString, generateStateOnChangeProp, generateStateValueProp, dlv as get, getDataProps, getStateCellsInPlasmicProxy, getStateSpecInPlasmicProxy, hasVariant, isPlasmicStateProxy, makeFragment, mergeVariantsWithStates, omit, pick, plasmicHeadMeta, renderPlasmicSlot, set, setPlumeStrictMode, useButton, useCheckbox, useCurrentUser, useDollarState, useIsSSR, useMenu, useMenuButton, useMenuGroup, useMenuItem, useSelect, useSelectOption, useSelectOptionGroup, useSwitch, useTextInput, useTrigger, useTriggeredOverlay, wrapWithClassName };
