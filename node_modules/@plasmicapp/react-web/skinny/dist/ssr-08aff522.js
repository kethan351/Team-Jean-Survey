import { PlasmicDataSourceContextProvider } from '@plasmicapp/data-sources-context';
import { SSRProvider, useIsSSR as useIsSSR$1 } from '@react-aria/ssr';
import * as React from 'react';
import React__default from 'react';
import { PlasmicHeadContext } from './render/PlasmicHead/index.js';

var PlasmicTranslatorContext = React__default.createContext(undefined);
function isIterable(val) {
    return val != null && typeof val[Symbol.iterator] === "function";
}
function genTranslatableString(elt) {
    var components = {};
    var componentsCount = 0;
    var getText = function (node) {
        if (!node) {
            return "";
        }
        if (typeof node === "number" ||
            typeof node === "boolean" ||
            typeof node === "string") {
            return node.toString();
        }
        if (typeof node !== "object") {
            return "";
        }
        if (Array.isArray(node) || isIterable(node)) {
            return Array.from(node)
                .map(function (child) { return getText(child); })
                .filter(function (child) { return !!child; })
                .join("");
        }
        var nodeChildren = (hasKey(node, "props") &&
            hasKey(node.props, "children") &&
            node.props.children) ||
            (hasKey(node, "children") && node.children) ||
            [];
        var contents = "".concat(React__default.Children.toArray(nodeChildren)
            .map(function (child) { return getText(child); })
            .filter(function (child) { return !!child; })
            .join(""));
        if (React__default.isValidElement(node) && node.type === React__default.Fragment) {
            return contents;
        }
        var componentId = componentsCount + 1;
        componentsCount++;
        components[componentId] = React__default.isValidElement(node)
            ? React__default.cloneElement(node, {
                key: componentId,
                children: undefined
            })
            : node;
        return "<".concat(componentId, ">").concat(contents, "</").concat(componentId, ">");
    };
    var str = getText(elt);
    return {
        str: str,
        components: components,
        componentsCount: componentsCount
    };
}
function Trans(_a) {
    var transKey = _a.transKey, children = _a.children;
    var _t = React__default.useContext(PlasmicTranslatorContext);
    if (!_t) {
        warnNoTranslationFunctionAtMostOnce();
        return children;
    }
    var _b = genTranslatableString(children), str = _b.str, components = _b.components, componentsCount = _b.componentsCount;
    return _t(transKey !== null && transKey !== void 0 ? transKey : str, componentsCount > 0 ? { components: components } : undefined);
}
var hasWarned = false;
function warnNoTranslationFunctionAtMostOnce() {
    if (!hasWarned) {
        console.warn("Using Plasmic Translation but no translation function has been provided");
        hasWarned = true;
    }
}
function hasKey(v, key) {
    return typeof v === "object" && v !== null && key in v;
}

var PlasmicRootContext = React.createContext(undefined);
function PlasmicRootProvider(props) {
    var _a = props, platform = _a.platform, children = _a.children, userAuthToken = _a.userAuthToken, isUserLoading = _a.isUserLoading, authRedirectUri = _a.authRedirectUri, user = _a.user;
    var context = React.useMemo(function () { return ({
        platform: platform
    }); }, [platform]);
    var dataSourceContextValue = React.useMemo(function () { return ({
        userAuthToken: userAuthToken,
        user: user,
        isUserLoading: isUserLoading,
        authRedirectUri: authRedirectUri
    }); }, [userAuthToken, isUserLoading, user, authRedirectUri]);
    return (React.createElement(PlasmicRootContext.Provider, { value: context },
        React.createElement(SSRProvider, null,
            React.createElement(PlasmicDataSourceContextProvider, { value: dataSourceContextValue },
                React.createElement(PlasmicTranslatorContext.Provider, { value: props.translator },
                    React.createElement(PlasmicHeadContext.Provider, { value: props.Head }, children))))));
}
var useIsSSR = useIsSSR$1;
function useHasPlasmicRoot() {
    return !!React.useContext(PlasmicRootContext);
}
var hasWarnedSSR = false;
/**
 * Warns the user if PlasmicRootProvider is not used
 */
function useEnsureSSRProvider() {
    var hasRoot = useHasPlasmicRoot();
    if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== "development") {
        return;
    }
    hasWarnedSSR = true;
    console.warn("Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr");
}

export { PlasmicRootProvider as P, Trans as T, useEnsureSSRProvider as a, genTranslatableString as g, useIsSSR as u };
//# sourceMappingURL=ssr-08aff522.js.map
