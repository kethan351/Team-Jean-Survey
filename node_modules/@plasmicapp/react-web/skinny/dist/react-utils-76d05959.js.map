{"version":3,"file":"react-utils-76d05959.js","sources":["../../src/react-utils.tsx"],"sourcesContent":["import classNames from \"classnames\";\nimport React from \"react\";\n\nexport const isBrowser = typeof window !== \"undefined\";\nexport const NONE = Symbol(\"NONE\");\n\nexport const useIsomorphicLayoutEffect = isBrowser\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nexport function createElementWithChildren(\n  elementType: any,\n  props: any,\n  children: React.ReactNode\n) {\n  if (Array.isArray(children)) {\n    return React.createElement(\n      elementType,\n      props,\n      ...children\n    ) as React.ReactElement;\n  } else if (children || \"children\" in props) {\n    // Only call React.createElement with `children` if there are actual children,\n    // or if there was an explicit (albeit undefined) children passed via\n    // props.  Otherwise, if you pass `undefined` as the children argument\n    // to React.createElement, the created element will have prop {children: undefined}.\n    // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}\n    // are used, then it will be taken as a `children` override, and will thus blank out\n    // everything under the root node.\n    return React.createElement(elementType, props, children);\n  } else {\n    return React.createElement(elementType, props);\n  }\n}\n\nexport function ensureNotArray(children: React.ReactNode) {\n  if (Array.isArray(children)) {\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return React.createElement(React.Fragment, {}, ...children);\n    }\n  } else {\n    return children;\n  }\n}\n\n/**\n * Flattens ReactNode into an array of ReactChild, but does NOT replace\n * missing keys with array index, as React.Children.toArray() does.\n */\nexport function toChildArray(children: React.ReactNode): React.ReactChild[] {\n  if (isReactChild(children)) {\n    return [children];\n  } else if (Array.isArray(children)) {\n    return children.flatMap(toChildArray);\n  } else {\n    return [];\n  }\n}\n\nexport function isReactText(child: React.ReactNode): child is React.ReactText {\n  return typeof child === \"string\" || typeof child === \"number\";\n}\n\nexport function isReactChild(\n  child: React.ReactNode\n): child is React.ReactChild {\n  return React.isValidElement(child) || isReactText(child);\n}\n\nexport function isReactFragment(\n  child: React.ReactNode\n): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === React.Fragment;\n}\n\nexport function isReactNode(x: any) {\n  return (\n    typeof x === \"string\" || typeof x === \"number\" || React.isValidElement(x)\n  );\n}\n\n// From https://stackoverflow.com/questions/54775790/forcing-excess-property-checking-on-variable-passed-to-typescript-function\n// We also wrap the error message in a Partial<> because otherwise Jetbrains IDEs will autocomplete the component with all the string methods as props - see https://github.com/plasmicapp/plasmic/issues/16.\nexport type StrictProps<T, TExpected> = Exclude<\n  keyof T,\n  keyof TExpected\n> extends never\n  ? {}\n  : Partial<\"Unexpected extraneous props\">;\n\nexport type HTMLElementRefOf<T extends keyof JSX.IntrinsicElements> = Exclude<\n  React.ComponentProps<T>[\"ref\"],\n  string\n>;\n\nexport function mergeProps(\n  props: Record<string, any>,\n  ...restProps: Record<string, any>[]\n): Record<string, any> {\n  if (restProps.every((rest) => Object.keys(rest).length === 0)) {\n    return props;\n  }\n\n  const result = { ...props };\n\n  for (const rest of restProps) {\n    for (const key of Object.keys(rest)) {\n      result[key] = mergePropVals(key, result[key], rest[key]);\n    }\n  }\n\n  return result;\n}\n\nfunction updateRef<T>(ref: React.Ref<T> | undefined, value: T | null) {\n  if (!ref) {\n    return;\n  }\n\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else {\n    if (!Object.isFrozen(ref)) {\n      (ref as React.MutableRefObject<T | null>).current = value;\n    }\n  }\n}\n\nexport function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {\n  return (value: T) => {\n    for (const ref of refs) {\n      updateRef(ref, value);\n    }\n  };\n}\n\nexport function mergePropVals(name: string, val1: any, val2: any): any {\n  if (val1 === NONE || val2 === NONE) {\n    // The NONE sentinel always skips all merging and returns null\n    return null;\n  } else if (val1 == null) {\n    // If either of them is nil, prefer the other\n    return val2;\n  } else if (val2 == null) {\n    return val1;\n  } else if (name === \"className\") {\n    // Special case for className -- always combine both class names\n    return classNames(val1, val2);\n  } else if (name === \"style\") {\n    // Special case for style -- always shallow-merge style dicts\n    return { ...val1, ...val2 };\n  } else if (name === \"ref\") {\n    // Special case for ref\n    return mergeRefs(val1, val2);\n  } else if (typeof val1 !== typeof val2) {\n    // If the type of the two values are different, then no way to merge them.\n    // Prefer val2.\n    return val2;\n  } else if (name.startsWith(\"on\") && typeof val1 === \"function\") {\n    // Special case for event handlers -- always call both handlers\n    return (...args: any[]) => {\n      let res: any;\n      if (typeof val1 === \"function\") {\n        res = val1(...args);\n      }\n      if (typeof val2 === \"function\") {\n        res = val2(...args);\n      }\n      return res;\n    };\n  } else {\n    // For all else, prefer val2\n    return val2;\n  }\n}\n\nexport function getElementTypeName(element: React.ReactElement) {\n  if (typeof element.type === \"string\") {\n    return element.type;\n  } else {\n    const comp = element.type as any;\n    return comp.displayName ?? comp.name ?? comp.render?.name ?? \"Component\";\n  }\n}\n"],"names":["React"],"mappings":"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"}