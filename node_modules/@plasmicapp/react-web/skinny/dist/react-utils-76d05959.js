import { f as __values, d as __spreadArray, e as __read, c as __assign } from './common-c2744215.js';
import classNames from 'classnames';
import React__default from 'react';

var isBrowser = typeof window !== "undefined";
var NONE = Symbol("NONE");
var useIsomorphicLayoutEffect = isBrowser
    ? React__default.useLayoutEffect
    : React__default.useEffect;
function createElementWithChildren(elementType, props, children) {
    if (Array.isArray(children)) {
        return React__default.createElement.apply(React__default, __spreadArray([elementType,
            props], __read(children), false));
    }
    else if (children || "children" in props) {
        // Only call React.createElement with `children` if there are actual children,
        // or if there was an explicit (albeit undefined) children passed via
        // props.  Otherwise, if you pass `undefined` as the children argument
        // to React.createElement, the created element will have prop {children: undefined}.
        // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}
        // are used, then it will be taken as a `children` override, and will thus blank out
        // everything under the root node.
        return React__default.createElement(elementType, props, children);
    }
    else {
        return React__default.createElement(elementType, props);
    }
}
function ensureNotArray(children) {
    if (Array.isArray(children)) {
        if (children.length === 1) {
            return children[0];
        }
        else {
            return React__default.createElement.apply(React__default, __spreadArray([React__default.Fragment, {}], __read(children), false));
        }
    }
    else {
        return children;
    }
}
/**
 * Flattens ReactNode into an array of ReactChild, but does NOT replace
 * missing keys with array index, as React.Children.toArray() does.
 */
function toChildArray(children) {
    if (isReactChild(children)) {
        return [children];
    }
    else if (Array.isArray(children)) {
        return children.flatMap(toChildArray);
    }
    else {
        return [];
    }
}
function isReactText(child) {
    return typeof child === "string" || typeof child === "number";
}
function isReactChild(child) {
    return React__default.isValidElement(child) || isReactText(child);
}
function isReactNode(x) {
    return (typeof x === "string" || typeof x === "number" || React__default.isValidElement(x));
}
function mergeProps(props) {
    var e_1, _a, e_2, _b;
    var restProps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        restProps[_i - 1] = arguments[_i];
    }
    if (restProps.every(function (rest) { return Object.keys(rest).length === 0; })) {
        return props;
    }
    var result = __assign({}, props);
    try {
        for (var restProps_1 = __values(restProps), restProps_1_1 = restProps_1.next(); !restProps_1_1.done; restProps_1_1 = restProps_1.next()) {
            var rest = restProps_1_1.value;
            try {
                for (var _c = (e_2 = void 0, __values(Object.keys(rest))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    result[key] = mergePropVals(key, result[key], rest[key]);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (restProps_1_1 && !restProps_1_1.done && (_a = restProps_1["return"])) _a.call(restProps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
function updateRef(ref, value) {
    if (!ref) {
        return;
    }
    if (typeof ref === "function") {
        ref(value);
    }
    else {
        if (!Object.isFrozen(ref)) {
            ref.current = value;
        }
    }
}
function mergeRefs() {
    var refs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
    }
    return function (value) {
        var e_3, _a;
        try {
            for (var refs_1 = __values(refs), refs_1_1 = refs_1.next(); !refs_1_1.done; refs_1_1 = refs_1.next()) {
                var ref = refs_1_1.value;
                updateRef(ref, value);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (refs_1_1 && !refs_1_1.done && (_a = refs_1["return"])) _a.call(refs_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
}
function mergePropVals(name, val1, val2) {
    if (val1 === NONE || val2 === NONE) {
        // The NONE sentinel always skips all merging and returns null
        return null;
    }
    else if (val1 == null) {
        // If either of them is nil, prefer the other
        return val2;
    }
    else if (val2 == null) {
        return val1;
    }
    else if (name === "className") {
        // Special case for className -- always combine both class names
        return classNames(val1, val2);
    }
    else if (name === "style") {
        // Special case for style -- always shallow-merge style dicts
        return __assign(__assign({}, val1), val2);
    }
    else if (name === "ref") {
        // Special case for ref
        return mergeRefs(val1, val2);
    }
    else if (typeof val1 !== typeof val2) {
        // If the type of the two values are different, then no way to merge them.
        // Prefer val2.
        return val2;
    }
    else if (name.startsWith("on") && typeof val1 === "function") {
        // Special case for event handlers -- always call both handlers
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var res;
            if (typeof val1 === "function") {
                res = val1.apply(void 0, __spreadArray([], __read(args), false));
            }
            if (typeof val2 === "function") {
                res = val2.apply(void 0, __spreadArray([], __read(args), false));
            }
            return res;
        };
    }
    else {
        // For all else, prefer val2
        return val2;
    }
}
function getElementTypeName(element) {
    var _a, _b, _c, _d;
    if (typeof element.type === "string") {
        return element.type;
    }
    else {
        var comp = element.type;
        return (_d = (_b = (_a = comp.displayName) !== null && _a !== void 0 ? _a : comp.name) !== null && _b !== void 0 ? _b : (_c = comp.render) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : "Component";
    }
}

export { NONE as N, mergePropVals as a, isBrowser as b, createElementWithChildren as c, mergeRefs as d, ensureNotArray as e, getElementTypeName as g, isReactNode as i, mergeProps as m, toChildArray as t, useIsomorphicLayoutEffect as u };
//# sourceMappingURL=react-utils-76d05959.js.map
