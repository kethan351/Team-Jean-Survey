import { e as __read, c as __assign, p as pick, d as __spreadArray } from '../../common-c2744215.js';
import { usePlasmicCanvasContext } from '@plasmicapp/host';
import { FocusScope } from '@react-aria/focus';
import { useOverlay, useOverlayPosition, DismissButton } from '@react-aria/overlays';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { d as mergeRefs, u as useIsomorphicLayoutEffect, m as mergeProps } from '../../react-utils-76d05959.js';
import { m as mergeVariantToggles } from '../../plume-utils-653f4b8a.js';
import { g as getStyleProps } from '../../props-utils-70c2d02a.js';
import { T as TriggeredOverlayContext } from '../../context-034b8d25.js';
export { T as TriggeredOverlayContext } from '../../context-034b8d25.js';
import 'classnames';

function useTriggeredOverlay(plasmicClass, props, config, outerRef, isDismissable) {
    var _a, _b;
    if (outerRef === void 0) { outerRef = null; }
    if (isDismissable === void 0) { isDismissable = true; }
    var overlayRef = React.useRef(null);
    var onOverlayRef = mergeRefs(overlayRef, outerRef);
    var context = React.useContext(TriggeredOverlayContext);
    if (!context) {
        // If no context, then we are not being correctly used.  Either complain, or
        // exit early.  It's okay to exit early and break the rules of React hooks
        // because we won't suddenly have the appropriate context anyway for this instance.
        {
            throw new Error("You can only use a triggered overlay with a TriggeredOverlayContext");
        }
    }
    var children = props.children;
    var triggerRef = context.triggerRef, placement = context.placement, overlayMatchTriggerWidth = context.overlayMatchTriggerWidth, overlayMinTriggerWidth = context.overlayMinTriggerWidth, overlayWidth = context.overlayWidth, state = context.state;
    // Measure the width of the trigger to inform the width of the menu (below).
    var _c = __read(React.useState(false), 2), isRendered = _c[0], setRendered = _c[1];
    var triggerWidth = triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth)
        ? triggerRef.current.offsetWidth
        : undefined;
    useIsomorphicLayoutEffect(function () {
        if (!isRendered &&
            triggerRef.current &&
            (overlayMatchTriggerWidth || overlayMinTriggerWidth)) {
            setRendered(true);
        }
    }, [
        triggerRef,
        isRendered,
        overlayMatchTriggerWidth,
        overlayMinTriggerWidth,
    ]);
    var overlayAriaProps = useOverlay({
        isOpen: state.isOpen,
        onClose: state.close,
        isDismissable: isDismissable,
        shouldCloseOnBlur: true
    }, overlayRef).overlayProps;
    var _d = useOverlayPosition({
        targetRef: triggerRef,
        overlayRef: overlayRef,
        placement: placement !== null && placement !== void 0 ? placement : "bottom left",
        shouldFlip: true,
        isOpen: state.isOpen,
        onClose: state.close,
        containerPadding: 0
    }), overlayPositionProps = _d.overlayProps, updatePosition = _d.updatePosition, placementAxis = _d.placement;
    useIsomorphicLayoutEffect(function () {
        if (state.isOpen) {
            requestAnimationFrame(function () {
                updatePosition();
            });
        }
    }, [state.isOpen, updatePosition]);
    var overlayProps = mergeProps({
        style: {
            left: "auto",
            right: "auto",
            top: "auto",
            bottom: "auto",
            position: "absolute",
            width: overlayWidth !== null && overlayWidth !== void 0 ? overlayWidth : (overlayMatchTriggerWidth ? triggerWidth : "auto"),
            minWidth: overlayMinTriggerWidth ? triggerWidth : "auto"
        }
    }, overlayAriaProps, overlayPositionProps);
    var variants = __assign(__assign({}, pick.apply(void 0, __spreadArray([props], __read(plasmicClass.internalVariantProps), false))), mergeVariantToggles({ def: config.isPlacedTopVariant, active: placementAxis === "top" }, { def: config.isPlacedBottomVariant, active: placementAxis === "bottom" }, { def: config.isPlacedLeftVariant, active: placementAxis === "left" }, { def: config.isPlacedRightVariant, active: placementAxis === "right" }));
    var canvasCtx = usePlasmicCanvasContext();
    var args = __assign(__assign({}, pick.apply(void 0, __spreadArray([props], __read(plasmicClass.internalArgProps), false))), (_a = {}, _a[config.contentSlot] = canvasCtx ? (children) : (React.createElement(FocusScope, { restoreFocus: true },
        React.createElement(DismissButton, { onDismiss: state.close }),
        children)), _a));
    var overrides = (_b = {},
        _b[config.root] = {
            props: mergeProps(overlayProps, getStyleProps(props), {
                ref: onOverlayRef
            }),
            wrap: function (root) {
                if (typeof document !== "undefined") {
                    return ReactDOM.createPortal(root, document.body);
                }
                else {
                    // Possibly being invoked on the server during SSR; no need to
                    // bother with a portal in that case.
                    return root;
                }
            }
        },
        _b);
    return {
        plasmicProps: {
            variants: variants,
            args: args,
            overrides: overrides
        }
    };
}

export { useTriggeredOverlay };
//# sourceMappingURL=index.js.map
