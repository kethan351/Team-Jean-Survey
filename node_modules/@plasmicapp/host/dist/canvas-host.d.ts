import * as React from "react";
declare global {
    interface Window {
        __PlasmicHostVersion: string;
    }
}
export declare function setPlasmicRootNode(node: React.ReactElement | null): void;
/**
 * React context to detect whether the component is rendered on Plasmic editor.
 * If not, return false.
 * If so, return an object with more information about the component
 */
export declare const PlasmicCanvasContext: React.Context<false | {
    componentName: string | null;
    globalVariants: Record<string, string>;
    interactive?: boolean | undefined;
}>;
export declare const usePlasmicCanvasContext: () => false | {
    componentName: string | null;
    globalVariants: Record<string, string>;
    interactive?: boolean | undefined;
};
interface PlasmicCanvasHostProps {
    /**
     * Webpack hmr uses EventSource to	listen to hot reloads, but that
     * resultsin a persistent	connection from	each window.  In Plasmic
     * Studio, if a project is configured to use app-hosting with a
     * nextjs or gatsby server running in dev mode, each artboard will
     * be holding a persistent connection to the dev server.
     * Because browsers	have a limit to	how many connections can
     * be held	at a time by domain, this means	after X	artboards, new
     * artboards will freeze and not load.
     *
     * By default, <PlasmicCanvasHost /> will globally mutate
     * window.EventSource to avoid using EventSource for HMR, which you
     * typically don't need for your custom host page.  If you do still
     * want to retain HRM, then youc an pass enableWebpackHmr={true}.
     */
    enableWebpackHmr?: boolean;
}
export declare const PlasmicCanvasHost: React.FunctionComponent<PlasmicCanvasHostProps>;
declare type RenderErrorListener = (err: Error) => void;
export declare function registerRenderErrorListener(listener: RenderErrorListener): () => void;
export {};
