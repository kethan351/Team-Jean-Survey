{"version":3,"file":"host.cjs.production.min.js","sources":["../src/canvas-host.tsx","../src/lang-utils.ts","../src/useForceUpdate.ts","../src/common.ts","../src/data.tsx","../src/fetcher.ts","../src/global-actions.tsx","../src/registerComponent.ts","../src/registerGlobalContext.ts","../src/registerToken.ts","../src/registerTrait.ts","../src/repeatedElement.ts","../src/index.ts","../src/version.ts"],"sourcesContent":["import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { ensure } from \"./lang-utils\";\nimport useForceUpdate from \"./useForceUpdate\";\nconst root = globalThis as any;\n\ndeclare global {\n  interface Window {\n    __PlasmicHostVersion: string;\n  }\n}\n\nif (root.__PlasmicHostVersion == null) {\n  root.__PlasmicHostVersion = \"2\";\n}\n\nconst rootChangeListeners: (() => void)[] = [];\nclass PlasmicRootNodeWrapper {\n  constructor(private value: null | React.ReactElement) {}\n  set = (val: null | React.ReactElement) => {\n    this.value = val;\n    rootChangeListeners.forEach((f) => f());\n  };\n  get = () => this.value;\n}\n\nconst plasmicRootNode = new PlasmicRootNodeWrapper(null);\n\nfunction getHashParams() {\n  return new URLSearchParams(location.hash.replace(/^#/, \"?\"));\n}\n\nfunction getPlasmicOrigin() {\n  const params = getHashParams();\n  return ensure(\n    params.get(\"origin\"),\n    \"Missing information from Plasmic window.\"\n  );\n}\n\nfunction getStudioHash() {\n  const hashParams = getHashParams();\n  if (hashParams.has(\"studioHash\")) {\n    return hashParams.get(\"studioHash\");\n  }\n  const urlParams = new URL(location.href).searchParams;\n  return urlParams.get(\"studio-hash\");\n}\n\nfunction renderStudioIntoIframe() {\n  const script = document.createElement(\"script\");\n  const plasmicOrigin = getPlasmicOrigin();\n  const hash = getStudioHash();\n  script.src = `${plasmicOrigin}/static/js/studio${\n    hash ? `.${hash}.js` : `.js`\n  }`;\n  document.body.appendChild(script);\n}\n\nlet renderCount = 0;\nexport function setPlasmicRootNode(node: React.ReactElement | null) {\n  // Keep track of renderCount, which we use as key to ErrorBoundary, so\n  // we can reset the error on each render\n  renderCount++;\n  plasmicRootNode.set(node);\n}\n\n/**\n * React context to detect whether the component is rendered on Plasmic editor.\n * If not, return false.\n * If so, return an object with more information about the component\n */\nexport const PlasmicCanvasContext = React.createContext<\n  | {\n      componentName: string | null;\n      globalVariants: Record<string, string>;\n      interactive?: boolean;\n    }\n  | false\n>(false);\nexport const usePlasmicCanvasContext = () =>\n  React.useContext(PlasmicCanvasContext);\n\nfunction _PlasmicCanvasHost() {\n  // If window.parent is null, then this is a window whose containing iframe\n  // has been detached from the DOM (for the top window, window.parent === window).\n  // In that case, we shouldn't do anything.  If window.parent is null, by the way,\n  // location.hash will also be null.\n  const isFrameAttached = !!window.parent;\n  const isCanvas = !!location.hash?.match(/\\bcanvas=true\\b/);\n  const isLive = !!location.hash?.match(/\\blive=true\\b/) || !isFrameAttached;\n  const shouldRenderStudio =\n    isFrameAttached &&\n    !document.querySelector(\"#plasmic-studio-tag\") &&\n    !isCanvas &&\n    !isLive;\n  const locationHash = new URLSearchParams(location.hash);\n\n  const [activeGlobalVariants, setActiveGlobalVariants] = React.useState<\n    Record<string, string>\n  >(() => JSON.parse(locationHash.get(\"globalVariants\") ?? \"{}\"));\n  const forceUpdate = useForceUpdate();\n  React.useLayoutEffect(() => {\n    rootChangeListeners.push(forceUpdate);\n    return () => {\n      const index = rootChangeListeners.indexOf(forceUpdate);\n      if (index >= 0) {\n        rootChangeListeners.splice(index, 1);\n      }\n    };\n  }, [forceUpdate]);\n  React.useEffect(() => {\n    if (shouldRenderStudio && isFrameAttached && window.parent !== window) {\n      renderStudioIntoIframe();\n    }\n  }, [shouldRenderStudio, isFrameAttached]);\n  React.useEffect(() => {\n    if (!shouldRenderStudio && !document.querySelector(\"#getlibs\") && isLive) {\n      const scriptElt = document.createElement(\"script\");\n      scriptElt.id = \"getlibs\";\n      scriptElt.src = getPlasmicOrigin() + \"/static/js/getlibs.js\";\n      scriptElt.async = false;\n      scriptElt.onload = () => {\n        (window as any).__GetlibsReadyResolver?.();\n      };\n      document.head.append(scriptElt);\n    }\n  }, [shouldRenderStudio]);\n  React.useEffect(() => {\n    const listener = (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data);\n        if (data.source === \"canvas-frame\") {\n          setActiveGlobalVariants(data.activeGlobalVariants);\n        }\n      } catch {}\n    };\n    window.addEventListener(\"message\", listener);\n    return () => window.removeEventListener(\"message\", listener);\n  }, []);\n  if (!isFrameAttached) {\n    return null;\n  }\n  if (isCanvas || isLive) {\n    let appDiv = document.querySelector(\"#plasmic-app.__wab_user-body\");\n    if (!appDiv) {\n      appDiv = document.createElement(\"div\");\n      appDiv.id = \"plasmic-app\";\n      appDiv.classList.add(\"__wab_user-body\");\n      document.body.appendChild(appDiv);\n    }\n    const plasmicContextValue = isCanvas\n      ? {\n          componentName: locationHash.get(\"componentName\"),\n          globalVariants: activeGlobalVariants,\n          interactive: !!locationHash.get(\"interactive\"),\n        }\n      : false;\n    return ReactDOM.createPortal(\n      <ErrorBoundary key={`${renderCount}`}>\n        <PlasmicCanvasContext.Provider value={plasmicContextValue}>\n          {plasmicRootNode.get()}\n        </PlasmicCanvasContext.Provider>\n      </ErrorBoundary>,\n      appDiv,\n      \"plasmic-app\"\n    );\n  }\n  if (shouldRenderStudio && window.parent === window) {\n    return (\n      <iframe\n        src={`https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=${encodeURIComponent(\n          location.href\n        )}`}\n        style={{\n          width: \"100vw\",\n          height: \"100vh\",\n          border: \"none\",\n          position: \"fixed\",\n          top: 0,\n          left: 0,\n          zIndex: 99999999,\n        }}\n      ></iframe>\n    );\n  }\n  return null;\n}\n\ninterface PlasmicCanvasHostProps {\n  /**\n   * Webpack hmr uses EventSource to\tlisten to hot reloads, but that\n   * resultsin a persistent\tconnection from\teach window.  In Plasmic\n   * Studio, if a project is configured to use app-hosting with a\n   * nextjs or gatsby server running in dev mode, each artboard will\n   * be holding a persistent connection to the dev server.\n   * Because browsers\thave a limit to\thow many connections can\n   * be held\tat a time by domain, this means\tafter X\tartboards, new\n   * artboards will freeze and not load.\n   *\n   * By default, <PlasmicCanvasHost /> will globally mutate\n   * window.EventSource to avoid using EventSource for HMR, which you\n   * typically don't need for your custom host page.  If you do still\n   * want to retain HRM, then youc an pass enableWebpackHmr={true}.\n   */\n  enableWebpackHmr?: boolean;\n}\n\nexport const PlasmicCanvasHost: React.FunctionComponent<PlasmicCanvasHostProps> = (\n  props\n) => {\n  const { enableWebpackHmr } = props;\n  const [node, setNode] = React.useState<React.ReactElement<any, any> | null>(\n    null\n  );\n  React.useEffect(() => {\n    setNode(<_PlasmicCanvasHost />);\n  }, []);\n  return (\n    <>\n      {!enableWebpackHmr && <DisableWebpackHmr />}\n      {node}\n    </>\n  );\n};\n\ntype RenderErrorListener = (err: Error) => void;\nconst renderErrorListeners: RenderErrorListener[] = [];\nexport function registerRenderErrorListener(listener: RenderErrorListener) {\n  renderErrorListeners.push(listener);\n  return () => {\n    const index = renderErrorListeners.indexOf(listener);\n    if (index >= 0) {\n      renderErrorListeners.splice(index, 1);\n    }\n  };\n}\n\ninterface ErrorBoundaryProps {\n  children?: React.ReactNode;\n}\n\ninterface ErrorBoundaryState {\n  error?: Error;\n}\n\nclass ErrorBoundary extends React.Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = {};\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n\n  componentDidCatch(error: Error) {\n    renderErrorListeners.forEach((listener) => listener(error));\n  }\n\n  render() {\n    if (this.state.error) {\n      return <div>Error: {`${this.state.error.message}`}</div>;\n    } else {\n      return <>{this.props.children}</>;\n    }\n  }\n}\n\nfunction DisableWebpackHmr() {\n  if (process.env.NODE_ENV === \"production\") {\n    return null;\n  }\n  return (\n    <script\n      type=\"text/javascript\"\n      dangerouslySetInnerHTML={{\n        __html: `\n      if (typeof window !== \"undefined\") {\n        const RealEventSource = window.EventSource;\n        window.EventSource = function(url, config) {\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\n            console.warn(\"Plasmic: disabled EventSource request for\", url);\n            return {\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\n            };\n          } else {\n            return new RealEventSource(url, config);\n          }\n        }\n      }\n      `,\n      }}\n    ></script>\n  );\n}\n","function isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\ntype StringGen = string | (() => string);\n\nexport function ensure<T>(x: T | null | undefined, msg: StringGen = \"\"): T {\n  if (x === null || x === undefined) {\n    debugger;\n    msg = (isString(msg) ? msg : msg()) || \"\";\n    throw new Error(\n      `Value must not be undefined or null${msg ? `- ${msg}` : \"\"}`\n    );\n  } else {\n    return x;\n  }\n}\n","import { useCallback, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  const [, setTick] = useState(0);\n  const update = useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n","export const tuple = <T extends any[]>(...args: T): T => args;\n","import React, {\n  createContext,\n  ReactElement,\n  ReactNode,\n  useContext,\n} from \"react\";\nimport { tuple } from \"./common\";\n\nexport type DataDict = Record<string, any>;\n\nexport const DataContext = createContext<DataDict | undefined>(undefined);\n\nexport type DataMeta = {\n  hidden?: boolean;\n  label?: string;\n};\n\nexport function mkMetaName(name: string) {\n  return `__plasmic_meta_${name}`;\n}\n\nexport function mkMetaValue(meta: Partial<DataMeta>): DataMeta {\n  return meta;\n}\n\nexport function applySelector(\n  rawData: DataDict | undefined,\n  selector: string | undefined\n): any {\n  if (!selector) {\n    return undefined;\n  }\n  let curData = rawData;\n  for (const key of selector.split(\".\")) {\n    curData = curData?.[key];\n  }\n  return curData;\n}\n\nexport type SelectorDict = Record<string, string | undefined>;\n\nexport function useSelector(selector: string | undefined): any {\n  const rawData = useDataEnv();\n  return applySelector(rawData, selector);\n}\n\nexport function useSelectors(selectors: SelectorDict = {}): any {\n  const rawData = useDataEnv();\n  return Object.fromEntries(\n    Object.entries(selectors)\n      .filter(([key, selector]) => !!key && !!selector)\n      .map(([key, selector]) => tuple(key, applySelector(rawData, selector)))\n  );\n}\n\nexport function useDataEnv() {\n  return useContext(DataContext);\n}\n\nexport interface DataProviderProps {\n  /**\n   * Key to set in data context.\n   */\n  name?: string;\n  /**\n   * Value to set for `name` in data context.\n   */\n  data?: any;\n  /**\n   * If true, hide this entry in studio (data binding).\n   */\n  hidden?: boolean;\n  /**\n   * Label to be shown in the studio data picker for easier navigation (data binding).\n   */\n  label?: string;\n  children?: ReactNode;\n}\n\nexport function DataProvider({\n  name,\n  data,\n  hidden,\n  label,\n  children,\n}: DataProviderProps) {\n  const existingEnv = useDataEnv() ?? {};\n  if (!name) {\n    return <>{children}</>;\n  } else {\n    return (\n      <DataContext.Provider\n        value={{\n          ...existingEnv,\n          [name]: data,\n          [mkMetaName(name)]: mkMetaValue({ hidden, label }),\n        }}\n      >\n        {children}\n      </DataContext.Provider>\n    );\n  }\n}\n\nexport interface PageParamsProviderProps {\n  params?: Record<string, string | string[] | undefined>;\n  query?: Record<string, string | string[] | undefined>;\n  children?: ReactNode;\n}\n\nexport function PageParamsProvider({\n  children,\n  params = {},\n  query = {},\n}: PageParamsProviderProps) {\n  const $ctx = useDataEnv() || {};\n  return (\n    <DataProvider\n      name={\"params\"}\n      data={{ ...$ctx.params, ...params }}\n      label={\"Page URL path params\"}\n    >\n      <DataProvider\n        name={\"query\"}\n        data={{ ...$ctx.query, ...query }}\n        label={\"Page URL query params\"}\n      >\n        {children}\n      </DataProvider>\n    </DataProvider>\n  );\n}\n\nexport function DataCtxReader({\n  children,\n}: {\n  children: ($ctx: DataDict | undefined) => ReactNode;\n}) {\n  const $ctx = useDataEnv();\n  return children($ctx) as ReactElement | null;\n}\n","import { PrimitiveType } from \"./registerComponent\";\n\nconst root = globalThis as any;\n\nexport type Fetcher = (...args: any[]) => Promise<any>;\n\nexport interface FetcherMeta {\n  /**\n   * Any unique identifying string for this fetcher.\n   */\n  name: string;\n  /**\n   * The Studio-user-friendly display name.\n   */\n  displayName?: string;\n  /**\n   * The symbol to import from the importPath.\n   */\n  importName?: string;\n  args: { name: string; type: PrimitiveType }[];\n  returns: PrimitiveType;\n  /**\n   * Either the path to the fetcher relative to `rootDir` or the npm\n   * package name\n   */\n  importPath: string;\n  /**\n   * Whether it's a default export or named export\n   */\n  isDefaultExport?: boolean;\n}\n\nexport interface FetcherRegistration {\n  fetcher: Fetcher;\n  meta: FetcherMeta;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFetcherRegistry: FetcherRegistration[];\n  }\n}\n\nroot.__PlasmicFetcherRegistry = [];\n\nexport function registerFetcher(fetcher: Fetcher, meta: FetcherMeta) {\n  root.__PlasmicFetcherRegistry.push({ fetcher, meta });\n}\n","import React from \"react\";\n\nexport type GlobalActionDict = Record<string, Function>;\n\nexport const GlobalActionsContext = React.createContext<\n  GlobalActionDict | undefined\n>(undefined);\n\nexport function GlobalActionsProvider(props: {\n  contextName: string;\n  children?: React.ReactNode;\n  actions: GlobalActionDict;\n}) {\n  const { contextName, children, actions } = props;\n  const namespacedActions = React.useMemo(\n    () =>\n      Object.fromEntries(\n        Object.entries(actions).map(([key, val]) => [\n          `${contextName}.${key}`,\n          val,\n        ])\n      ),\n    [contextName, actions]\n  );\n  return (\n    <GlobalActionsContext.Provider value={namespacedActions}>\n      {children}\n    </GlobalActionsContext.Provider>\n  );\n}\n\nexport function useGlobalActions() {\n  return React.useContext(GlobalActionsContext) ?? {};\n}\n","import {\n  CodeComponentElement,\n  CSSProperties,\n  PlasmicElement,\n} from \"./element-types\";\n\nconst root = globalThis as any;\n\nexport interface CanvasComponentProps<Data = any> {\n  /**\n   * This prop is only provided within the canvas of Plasmic Studio.\n   * Allows the component to set data to be consumed by the props' controls.\n   */\n  setControlContextData?: (data: Data) => void;\n}\n\ntype InferDataType<P> = P extends CanvasComponentProps<infer Data> ? Data : any;\n\n/**\n * Config option that takes the context (e.g., props) of the component instance\n * to dynamically set its value.\n */\nexport type ContextDependentConfig<P, R> = (\n  props: P,\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null\n) => R;\n\nexport interface PropTypeBase<P> {\n  displayName?: string;\n  description?: string;\n  helpText?: string;\n  /**\n   * If the user has chosen to use a dynamic expression for this prop, provide\n   * a hint as to the expected values that the expression should evaluate to.\n   * This hint will be displayed alongside the code editor.  You may use\n   * markdown in the text here.\n   */\n  exprHint?: string;\n  hidden?: ContextDependentConfig<P, boolean>;\n  readOnly?: boolean | ContextDependentConfig<P, boolean>;\n  advanced?: boolean;\n  disableDynamicValue?: boolean;\n}\n\nexport type DefaultValueOrExpr<P, T> =\n  | {\n      defaultExpr?: undefined;\n      defaultExprHint?: undefined;\n      defaultValue?: T;\n      defaultValueHint?: T | ContextDependentConfig<P, T | undefined>;\n    }\n  | {\n      defaultValue?: undefined;\n      defaultValueHint?: undefined;\n      defaultExpr?: string;\n      defaultExprHint?: string;\n    };\n\ntype StringTypeBase<P> = PropTypeBase<P> & DefaultValueOrExpr<P, string>;\n\nexport type StringType<P> =\n  | \"string\"\n  | ((\n      | {\n          type: \"string\";\n          control?: \"default\" | \"large\";\n        }\n      | {\n          type: \"code\";\n          lang: \"css\" | \"html\" | \"javascript\" | \"json\";\n        }\n      | {\n          type: \"richText\";\n        }\n      | {\n          type: \"color\";\n          /**\n           * If specified, and the user picks a color token in the Studio, then\n           * the value passed in as prop is a css variable reference, like\n           * `var(--TOKEN_ID)`, instead of the resolved hex value of the token.\n           * You should take care in using this in the proper css context --\n           * the css token is only defined if you are rendering under some\n           * Plasmic component in the DOM tree, which is usually the case,\n           * unless you are using a React portal.\n           */\n          keepCssVar?: boolean;\n        }\n      | {\n          type: \"cardPicker\";\n          modalTitle?:\n            | React.ReactNode\n            | ContextDependentConfig<P, React.ReactNode>;\n          options:\n            | {\n                value: string;\n                label?: string;\n                imgUrl: string;\n                footer?: React.ReactNode;\n              }[]\n            | ContextDependentConfig<\n                P,\n                {\n                  value: string;\n                  label?: string;\n                  imgUrl: string;\n                  footer?: React.ReactNode;\n                }[]\n              >;\n          showInput?: boolean | ContextDependentConfig<P, boolean>;\n          onSearch?: ContextDependentConfig<\n            P,\n            ((value: string) => void) | undefined\n          >;\n        }\n    ) &\n      StringTypeBase<P>);\n\nexport type BooleanType<P> =\n  | \"boolean\"\n  | ({\n      type: \"boolean\";\n    } & DefaultValueOrExpr<P, boolean> &\n      PropTypeBase<P>);\n\ntype GraphQLValue = {\n  query: string;\n  variables?: Record<string, any>;\n};\n\nexport type GraphQLType<P> = {\n  type: \"code\";\n  lang: \"graphql\";\n  endpoint: string | ContextDependentConfig<P, string>;\n  method?: string | ContextDependentConfig<P, string>;\n  headers?: object | ContextDependentConfig<P, object>;\n} & DefaultValueOrExpr<P, GraphQLValue> &\n  PropTypeBase<P>;\n\ntype NumberTypeBase<P> = PropTypeBase<P> &\n  DefaultValueOrExpr<P, number> & {\n    type: \"number\";\n  };\n\nexport type NumberType<P> =\n  | \"number\"\n  | ((\n      | {\n          control?: \"default\";\n          min?: number | ContextDependentConfig<P, number>;\n          max?: number | ContextDependentConfig<P, number>;\n        }\n      | {\n          control: \"slider\";\n          min: number | ContextDependentConfig<P, number>;\n          max: number | ContextDependentConfig<P, number>;\n          step?: number | ContextDependentConfig<P, number>;\n        }\n    ) &\n      NumberTypeBase<P>);\n\n/**\n * Expects defaultValue to be a JSON-compatible value\n */\nexport type JSONLikeType<P> =\n  | \"object\"\n  | ({\n      type: \"object\";\n      fields?: {\n        [p: string]: PropType<P>;\n      };\n    } & DefaultValueOrExpr<P, any> &\n      PropTypeBase<P>)\n  | ({\n      type: \"array\";\n      itemType?: {\n        type: \"object\";\n        fields: {\n          [p: string]: PropType<P>;\n        };\n        /**\n         * Optional function that generates a name for this item in the array\n         */\n        nameFunc?: (item: any) => string | undefined;\n      };\n    } & DefaultValueOrExpr<P, any[]> &\n      PropTypeBase<P>)\n  | ({\n      type: \"dataSource\";\n      dataSource: \"airtable\" | \"cms\";\n    } & PropTypeBase<P>);\n\ntype DataPickerValueType = string | number | (string | number)[];\n\nexport type DataPickerType<P> =\n  | ({\n      type: \"dataSelector\";\n      data:\n        | Record<string, any>\n        | ContextDependentConfig<P, Record<string, any>>;\n      alwaysShowValuePathAsLabel?: boolean;\n    } & DefaultValueOrExpr<P, DataPickerValueType> &\n      PropTypeBase<P>)\n  | ({\n      type: \"exprEditor\";\n      data:\n        | Record<string, any>\n        | ContextDependentConfig<P, Record<string, any>>;\n    } & DefaultValueOrExpr<P, DataPickerValueType> &\n      PropTypeBase<P>);\n\ninterface ChoiceTypeBase<P> extends PropTypeBase<P> {\n  type: \"choice\";\n  options:\n    | string[]\n    | {\n        label: string;\n        value: string | number | boolean;\n      }[]\n    | ContextDependentConfig<\n        P,\n        | string[]\n        | {\n            label: string;\n            value: string | number | boolean;\n          }[]\n      >;\n  allowSearch?: boolean;\n  filterOption?: boolean;\n  onSearch?: ContextDependentConfig<P, ((value: string) => void) | undefined>;\n}\n\nexport type ChoiceType<P> = (\n  | ({\n      multiSelect?: false;\n    } & DefaultValueOrExpr<P, string | number | boolean>)\n  | ({\n      multiSelect: true;\n    } & DefaultValueOrExpr<P, (string | number | boolean)[]>)\n  | ({\n      multiSelect: ContextDependentConfig<P, boolean>;\n    } & DefaultValueOrExpr<\n      P,\n      string | number | boolean | (string | number | boolean)[]\n    >)\n) &\n  ChoiceTypeBase<P>;\n\nexport interface ModalProps {\n  show?: boolean;\n  children?: React.ReactNode;\n  onClose: () => void;\n  style?: CSSProperties;\n}\n\ninterface CustomControlProps<P> {\n  componentProps: P;\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null;\n  value: any;\n  /**\n   * Sets the value to be passed to the prop. Expects a JSON-compatible value.\n   */\n  updateValue: (newVal: any) => void;\n  /**\n   * Full screen modal component\n   */\n  FullscreenModal: React.ComponentType<ModalProps>;\n  /**\n   * Modal component for the side pane\n   */\n  SideModal: React.ComponentType<ModalProps>;\n\n  /**\n   * The document that the component will be rendered into; instead of using\n   * `document` directly (for, say, `document.querySelector()` etc.), you\n   * should use this instead.\n   */\n  studioDocument: typeof document;\n}\nexport type CustomControl<P> = React.ComponentType<CustomControlProps<P>>;\n\n/**\n * Expects defaultValue to be a JSON-compatible value\n */\nexport type CustomType<P> =\n  | CustomControl<P>\n  | ({\n      type: \"custom\";\n      control: CustomControl<P>;\n    } & PropTypeBase<P> &\n      DefaultValueOrExpr<P, any>);\n\ntype SlotType<P> =\n  | \"slot\"\n  | ({\n      type: \"slot\";\n      /**\n       * The unique names of all code components that can be placed in the slot\n       */\n      allowedComponents?: string[];\n      /**\n       * Whether the \"empty slot\" placeholder should be hidden in the canvas.\n       */\n      hidePlaceholder?: boolean;\n      /**\n       * Whether the slot is repeated, i.e., is rendered multiple times using\n       * repeatedElement().\n       */\n      isRepeated?: boolean;\n\n      /**\n       * If slot is a render prop (accepts a function that takes in some\n       * arguments and returns some JSX), then specify the names of the\n       * arguments expected by the render prop function.\n       */\n      renderPropParams?: string[];\n    } & Omit<\n      DefaultValueOrExpr<P, PlasmicElement | PlasmicElement[]>,\n      \"defaultValueHint\" | \"defaultExpr\" | \"defaultExprHint\"\n    >);\n\ntype ImageUrlType<P> =\n  | \"imageUrl\"\n  | ({\n      type: \"imageUrl\";\n    } & DefaultValueOrExpr<P, string> &\n      PropTypeBase<P>);\n\nexport type PrimitiveType<P = any> = Extract<\n  StringType<P> | BooleanType<P> | NumberType<P> | JSONLikeType<P>,\n  String\n>;\n\ntype ControlTypeBase =\n  | {\n      editOnly?: false;\n    }\n  | {\n      editOnly: true;\n      /**\n       * The prop where the values should be mapped to\n       */\n      uncontrolledProp?: string;\n    };\n\nexport type SupportControlled<T> =\n  | Extract<T, String | CustomControl<any>>\n  | (Exclude<T, String | CustomControl<any>> & ControlTypeBase);\n\nexport type PropType<P> =\n  | SupportControlled<\n      | StringType<P>\n      | BooleanType<P>\n      | NumberType<P>\n      | JSONLikeType<P>\n      | ChoiceType<P>\n      | ImageUrlType<P>\n      | CustomType<P>\n      | GraphQLType<P>\n      | DataPickerType<P>\n    >\n  | SlotType<P>;\n\ntype RestrictPropType<T, P> = T extends string\n  ? SupportControlled<\n      | StringType<P>\n      | ChoiceType<P>\n      | JSONLikeType<P>\n      | ImageUrlType<P>\n      | CustomType<P>\n      | DataPickerType<P>\n    >\n  : T extends boolean\n  ? SupportControlled<\n      BooleanType<P> | JSONLikeType<P> | CustomType<P> | DataPickerType<P>\n    >\n  : T extends number\n  ? SupportControlled<\n      NumberType<P> | JSONLikeType<P> | CustomType<P> | DataPickerType<P>\n    >\n  : PropType<P>;\n\nexport interface ActionProps<P> {\n  componentProps: P;\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null;\n  studioOps: {\n    showModal: (\n      modalProps: Omit<ModalProps, \"onClose\"> & { onClose?: () => void }\n    ) => void;\n    refreshQueryData: () => void;\n    appendToSlot: (element: PlasmicElement, slotName: string) => void;\n    removeFromSlotAt: (pos: number, slotName: string) => void;\n    updateProps: (newValues: any) => void;\n  };\n  /**\n   * The document that the component will be rendered into; instead of using\n   * `document` directly (for, say, `document.querySelector()` etc.), you\n   * should use this instead.\n   */\n  studioDocument: typeof document;\n}\n\nexport type Action<P> =\n  | {\n      type: \"button-action\";\n      label: string;\n      onClick: (props: ActionProps<P>) => void;\n    }\n  | {\n      type: \"custom-action\";\n      control: React.ComponentType<ActionProps<P>>;\n    };\n\ntype DistributedKeyOf<T> = T extends any ? keyof T : never;\n\ninterface ComponentTemplate<P>\n  extends Omit<CodeComponentElement<P>, \"type\" | \"name\"> {\n  /**\n   * A preview picture for the template.\n   */\n  previewImg?: string;\n}\n\nexport interface ComponentTemplates<P> {\n  [name: string]: ComponentTemplate<P>;\n}\ninterface $State {\n  [key: string]: any;\n}\n\ninterface $StateSpec<T> {\n  // Whether this state is private, readonly, or writable in\n  // this component\n  type: \"private\" | \"readonly\" | \"writable\";\n  // if initial value is defined by a js expression\n  initFunc?: ($props: Record<string, any>, $state: $State) => T;\n\n  // if initial value is a hard-coded value\n  initVal?: T;\n  // Whether this state is private, readonly, or writable in\n  // this component\n\n  // If writable, there should be a valueProp that maps props[valueProp]\n  // to the value of the state\n  valueProp?: string;\n\n  // If writable or readonly, there should be an onChangeProp where\n  // props[onChangeProp] is invoked whenever the value changes\n  onChangeProp?: string;\n}\n\nexport interface ComponentMeta<P> {\n  /**\n   * Any unique string name used to identify that component. Each component\n   * should be registered with a different `meta.name`, even if they have the\n   * same name in the code.\n   */\n  name: string;\n  /**\n   * The name to be displayed for the component in Studio. Optional: if not\n   * specified, `meta.name` is used.\n   */\n  displayName?: string;\n  /**\n   * The description of the component to be shown in Studio.\n   */\n  description?: string;\n  /**\n   * The javascript name to be used when generating code. Optional: if not\n   * provided, `meta.name` is used.\n   */\n  importName?: string;\n  /**\n   * An object describing the component properties to be used in Studio.\n   * For each `prop`, there should be an entry `meta.props[prop]` describing\n   * its type.\n   */\n  props: { [prop in DistributedKeyOf<P>]?: RestrictPropType<P[prop], P> } & {\n    [prop: string]: PropType<P>;\n  };\n  /**\n   * WIP: An object describing the component states to be used in Studio.\n   */\n  unstable__states?: Record<string, $StateSpec<any>>;\n  /**\n   * An array describing the component actions to be used in Studio.\n   */\n  actions?: Action<P>[];\n  /**\n   * Whether style sections should be shown in Studio. For styles to work, the\n   * component must accept a `className` prop. If unset, defaults to true.\n   */\n  styleSections?: boolean;\n  /**\n   * Whether the element can be repeated in Studio. If unset, defaults to true.\n   */\n  isRepeatable?: boolean;\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   *  Whether the component is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n  /**\n   * The prop that expects the CSS classes with styles to be applied to the\n   * component. Optional: if not specified, Plasmic will expect it to be\n   * `className`. Notice that if the component does not accept CSS classes, the\n   * component will not be able to receive styles from the Studio.\n   */\n  classNameProp?: string;\n  /**\n   * The prop that receives and forwards a React `ref`. Plasmic only uses `ref`\n   * to interact with components, so it's not used in the generated code.\n   * Optional: If not provided, the usual `ref` is used.\n   */\n  refProp?: string;\n  /**\n   * Default styles to start with when instantiating the component in Plasmic.\n   */\n  defaultStyles?: CSSProperties;\n  /**\n   * Component templates to start with on Plasmic.\n   */\n  templates?: ComponentTemplates<P>;\n  /**\n   * Registered name of parent component, used for grouping related components.\n   */\n  parentComponentName?: string;\n  /**\n   * Whether the component can be used as an attachment to an element.\n   */\n  isAttachment?: boolean;\n  /**\n   * Whether the component provides data to its slots using DataProvider.\n   */\n  providesData?: boolean;\n\n  /**\n   * If specified, then Figma components with the specified names will be mapped\n   * to this component when you paste Figma content into Plasmic\n   */\n  figmaMappings?: {\n    figmaComponentName: string;\n  }[];\n\n  /**\n   * If true, when an instance of this component is added, the element\n   * will always be named by the name of this component.\n   */\n  alwaysAutoName?: boolean;\n\n  unstable__refActions?: Record<string, RefActionRegistration<P>>;\n}\n\nexport interface FunctionParam<P> {\n  name: string;\n  displayName?: string;\n  type: PropType<P>;\n}\n\nexport interface RefActionRegistration<P> {\n  displayName?: string;\n  description?: string;\n  parameters: FunctionParam<P>[];\n}\n\nexport interface ComponentRegistration {\n  component: React.ComponentType<any>;\n  meta: ComponentMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicComponentRegistry: ComponentRegistration[];\n  }\n}\n\nif (root.__PlasmicComponentRegistry == null) {\n  root.__PlasmicComponentRegistry = [];\n}\n\nexport default function registerComponent<T extends React.ComponentType<any>>(\n  component: T,\n  meta: ComponentMeta<React.ComponentProps<T>>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicComponentRegistry.some(\n      (r: ComponentRegistration) =>\n        r.component === component && r.meta.name === meta.name\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicComponentRegistry.push({ component, meta });\n}\n","import {\n  BooleanType,\n  ChoiceType,\n  CustomType,\n  FunctionParam,\n  JSONLikeType,\n  NumberType,\n  StringType,\n  SupportControlled,\n} from \"./registerComponent\";\n\nconst root = globalThis as any;\n\nexport type PropType<P> = SupportControlled<\n  | StringType<P>\n  | BooleanType<P>\n  | NumberType<P>\n  | JSONLikeType<P>\n  | ChoiceType<P>\n  | CustomType<P>\n>;\n\ntype RestrictPropType<T, P> = T extends string\n  ? SupportControlled<\n      StringType<P> | ChoiceType<P> | JSONLikeType<P> | CustomType<P>\n    >\n  : T extends boolean\n  ? SupportControlled<BooleanType<P> | JSONLikeType<P> | CustomType<P>>\n  : T extends number\n  ? SupportControlled<NumberType<P> | JSONLikeType<P> | CustomType<P>>\n  : PropType<P>;\n\ntype DistributedKeyOf<T> = T extends any ? keyof T : never;\n\nexport interface GlobalContextMeta<P> {\n  /**\n   * Any unique string name used to identify that context. Each context\n   * should be registered with a different `meta.name`, even if they have the\n   * same name in the code.\n   */\n  name: string;\n  /**\n   * The name to be displayed for the context in Studio. Optional: if not\n   * specified, `meta.name` is used.\n   */\n  displayName?: string;\n  /**\n   * The description of the context to be shown in Studio.\n   */\n  description?: string;\n  /**\n   * The javascript name to be used when generating code. Optional: if not\n   * provided, `meta.name` is used.\n   */\n  importName?: string;\n  /**\n   * An object describing the context properties to be used in Studio.\n   * For each `prop`, there should be an entry `meta.props[prop]` describing\n   * its type.\n   */\n  props: { [prop in DistributedKeyOf<P>]?: RestrictPropType<P[prop], P> } & {\n    [prop: string]: PropType<P>;\n  };\n  /**\n   * The path to be used when importing the context in the generated code.\n   * It can be the name of the package that contains the context, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   *  Whether the context is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n  /**\n   * The prop that receives and forwards a React `ref`. Plasmic only uses `ref`\n   * to interact with components, so it's not used in the generated code.\n   * Optional: If not provided, the usual `ref` is used.\n   */\n  refProp?: string;\n  /**\n   * Whether the global context provides data to its children using DataProvider.\n   */\n  providesData?: boolean;\n\n  unstable__globalActions?: Record<string, GlobalActionRegistration<P>>;\n}\n\nexport interface GlobalContextRegistration {\n  component: React.ComponentType<any>;\n  meta: GlobalContextMeta<any>;\n}\n\nexport interface GlobalActionRegistration<P> {\n  displayName?: string;\n  description?: string;\n  parameters: FunctionParam<P>[];\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicContextRegistry: GlobalContextRegistration[];\n  }\n}\n\nif (root.__PlasmicContextRegistry == null) {\n  root.__PlasmicContextRegistry = [];\n}\n\nexport default function registerGlobalContext<\n  T extends React.ComponentType<any>\n>(component: T, meta: GlobalContextMeta<React.ComponentProps<T>>) {\n  // Check for duplicates\n  if (\n    root.__PlasmicContextRegistry.some(\n      (r: GlobalContextRegistration) =>\n        r.component === component && r.meta.name === meta.name\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicContextRegistry.push({ component, meta });\n}\n","export type TokenType =\n  | \"color\"\n  | \"spacing\"\n  | \"font-family\"\n  | \"font-size\"\n  | \"line-height\"\n  | \"opacity\";\n\nexport interface TokenRegistration {\n  name: string;\n  value: string;\n  type: TokenType;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicTokenRegistry: TokenRegistration[];\n  }\n}\n\nconst root = globalThis as any;\n\nif (root.__PlasmicTokenRegistry == null) {\n  root.__PlasmicTokenRegistry = [];\n}\n\nexport default function registerToken(token: TokenRegistration) {\n  root.__PlasmicTokenRegistry.push(token);\n}\n","const root = globalThis as any;\n\nexport interface BasicTrait {\n  label?: string;\n  type: \"text\" | \"number\" | \"boolean\";\n}\n\nexport interface ChoiceTrait {\n  label?: string;\n  type: \"choice\";\n  options: string[];\n}\n\nexport type TraitMeta = BasicTrait | ChoiceTrait;\n\nexport interface TraitRegistration {\n  trait: string;\n  meta: TraitMeta;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicTraitRegistry: TraitRegistration[];\n  }\n}\n\nif (root.__PlasmicTraitRegistry == null) {\n  root.__PlasmicTraitRegistry = [];\n}\n\nexport default function registerTrait(trait: string, meta: TraitMeta) {\n  root.__PlasmicTraitRegistry.push({\n    trait,\n    meta,\n  });\n}\n","import { cloneElement, isValidElement } from \"react\";\n\n/**\n * Allows elements to be repeated in Plasmic Studio.\n * @param index The index of the copy (starting at 0).\n * @param elt the React element to be repeated (or an array of such).\n */\nexport default function repeatedElement<T>(index: number, elt: T): T;\n/**\n * Allows elements to be repeated in Plasmic Studio.\n * @param isPrimary should be true for at most one instance of the element, and\n * indicates which copy of the element will be highlighted when the element is\n * selected in Studio.\n * @param elt the React element to be repeated (or an array of such).\n */\nexport default function repeatedElement<T>(isPrimary: boolean, elt: T): T;\nexport default function repeatedElement<T>(index: boolean | number, elt: T): T {\n  return repeatedElementFn(index as any, elt);\n}\n\nlet repeatedElementFn: typeof repeatedElement = (\n  index: boolean | number,\n  elt: any\n) => {\n  if (Array.isArray(elt)) {\n    return elt.map((v) => repeatedElementFn(index as any, v)) as any;\n  }\n  if (elt && isValidElement(elt) && typeof elt !== \"string\") {\n    return cloneElement(elt) as any;\n  }\n  return elt;\n};\n\nconst root = globalThis as any;\nexport const setRepeatedElementFn: (fn: typeof repeatedElement) => void =\n  root?.__Sub?.setRepeatedElementFn ??\n  function (fn: typeof repeatedElement) {\n    repeatedElementFn = fn;\n  };\n","import * as PlasmicQuery from \"@plasmicapp/query\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { registerRenderErrorListener, setPlasmicRootNode } from \"./canvas-host\";\nimport * as hostModule from \"./exports\";\nimport { setRepeatedElementFn } from \"./repeatedElement\";\n// version.ts is automatically generated by `yarn build` and not committed.\nimport { hostVersion } from \"./version\";\n\n// All exports must come from \"./exports\"\nexport * from \"./exports\";\n\nconst root = globalThis as any;\n\nif (root.__Sub == null) {\n  // Creating a side effect here by logging, so that vite won't\n  // ignore this block for whatever reason. Hiding this for now\n  // as users are complaining; will have to check if this has\n  // been fixed with vite.\n  // console.log(\"Plasmic: Setting up app host dependencies\");\n  root.__Sub = {\n    React,\n    ReactDOM,\n    PlasmicQuery,\n    hostModule,\n    hostVersion,\n    hostUtils: {\n      setPlasmicRootNode,\n      registerRenderErrorListener,\n      setRepeatedElementFn,\n    },\n\n    // For backwards compatibility:\n    setPlasmicRootNode,\n    registerRenderErrorListener,\n    setRepeatedElementFn,\n    ...hostModule,\n  };\n}\n","export const hostVersion = \"1.0.111\";\n"],"names":["root","globalThis","__PlasmicHostVersion","rootChangeListeners","plasmicRootNode","value","this","val","_this","forEach","f","getHashParams","URLSearchParams","location","hash","replace","getPlasmicOrigin","x","msg","isString","Error","ensure","get","renderCount","setPlasmicRootNode","node","set","PlasmicCanvasContext","React","usePlasmicCanvasContext","_PlasmicCanvasHost","setTick","isFrameAttached","window","parent","isCanvas","_location$hash","match","isLive","_location$hash2","shouldRenderStudio","document","querySelector","locationHash","JSON","parse","activeGlobalVariants","setActiveGlobalVariants","forceUpdate","useState","useCallback","tick","push","index","indexOf","splice","hashParams","script","plasmicOrigin","createElement","has","URL","href","searchParams","src","body","appendChild","scriptElt","id","async","onload","__GetlibsReadyResolver","head","append","listener","event","data","source","addEventListener","removeEventListener","appDiv","classList","add","plasmicContextValue","componentName","globalVariants","interactive","ReactDOM","ErrorBoundary","key","Provider","encodeURIComponent","style","width","height","border","position","top","left","zIndex","PlasmicCanvasHost","props","enableWebpackHmr","setNode","DisableWebpackHmr","renderErrorListeners","registerRenderErrorListener","_this2","state","getDerivedStateFromError","error","_proto","componentDidCatch","render","message","children","DataContext","createContext","undefined","mkMetaName","name","mkMetaValue","meta","applySelector","rawData","selector","curData","split","_curData","useSelector","useDataEnv","useSelectors","selectors","Object","fromEntries","entries","filter","map","args","tuple","useContext","DataProvider","hidden","label","existingEnv","PageParamsProvider","_ref4$params","params","_ref4$query","query","$ctx","DataCtxReader","registerFetcher","fetcher","__PlasmicFetcherRegistry","GlobalActionsContext","GlobalActionsProvider","contextName","actions","namespacedActions","useMemo","useGlobalActions","registerComponent","component","__PlasmicComponentRegistry","some","r","registerGlobalContext","__PlasmicContextRegistry","registerToken","token","__PlasmicTokenRegistry","registerTrait","trait","__PlasmicTraitRegistry","repeatedElement","elt","repeatedElementFn","Array","isArray","v","isValidElement","cloneElement","setRepeatedElementFn","__Sub","_root$__Sub","fn","PlasmicQuery","hostModule","hostVersion","hostUtils"],"mappings":"4pBAIA,IAAMA,EAAOC,WAQoB,MAA7BD,EAAKE,uBACPF,EAAKE,qBAAuB,KAG9B,IAAMC,EAAsC,GAUtCC,EAAkB,IARtB,SAAoBC,cAAAC,WAQ6B,KAPjDA,SAAM,SAACC,GACLC,EAAKH,MAAQE,EACbJ,EAAoBM,SAAQ,SAACC,GAAC,OAAKA,QAErCJ,SAAM,WAAA,OAAME,EAAKH,OAGK,CAA2B,MAEnD,SAASM,IACP,OAAO,IAAIC,gBAAgBC,SAASC,KAAKC,QAAQ,KAAM,MAGzD,SAASC,IAEP,gBC5BwBC,EAAyBC,GACjD,YADiDA,IAAAA,EAAiB,IAC9DD,MAAAA,EAGF,MADAC,GATJ,SAAkBD,GAChB,MAAoB,iBAANA,EAQLE,CAASD,GAAOA,EAAMA,MAAU,GACjC,IAAIE,6CAC8BF,OAAWA,EAAQ,KAG3D,OAAOD,EDoBFI,CADQV,IAENW,IAAI,UACX,4CAuBJ,IAAIC,EAAc,WACFC,EAAmBC,GAGjCF,IACAnB,EAAgBsB,IAAID,OAQTE,EAAuBC,iBAOlC,GACWC,EAA0B,WAAH,OAClCD,aAAiBD,IAEnB,SAASG,YEhFEC,EFqFHC,IAAoBC,OAAOC,OAC3BC,aAAatB,SAASC,QAATsB,EAAeC,MAAM,oBAClCC,aAAWzB,SAASC,QAATyB,EAAeF,MAAM,oBAAqBL,EACrDQ,EACJR,IACCS,SAASC,cAAc,yBACvBP,IACAG,EACGK,EAAe,IAAI/B,gBAAgBC,SAASC,QAEMc,YAEtD,WAAA,MAAA,OAAMgB,KAAKC,eAAMF,EAAarB,IAAI,qBAAqB,SAFlDwB,OAAsBC,OAGvBC,GElGGjB,EAAWkB,WAAS,MACdC,eAAY,WACzBnB,GAAQ,SAACoB,GAAI,OAAKA,EAAO,OACxB,KFsIH,GAtCAvB,mBAAsB,WAEpB,OADAzB,EAAoBiD,KAAKJ,GAClB,WACL,IAAMK,EAAQlD,EAAoBmD,QAAQN,GACtCK,GAAS,GACXlD,EAAoBoD,OAAOF,EAAO,MAGrC,CAACL,IACJpB,aAAgB,WA9DlB,IARQ4B,EASAC,EACAC,EACA5C,EA4DA0B,GAAsBR,GAAmBC,OAAOC,SAAWD,SA9D3DwB,EAAShB,SAASkB,cAAc,UAChCD,EAAgB1C,IAChBF,GAXA0C,EAAa7C,KACJiD,IAAI,cACVJ,EAAWlC,IAAI,cAEN,IAAIuC,IAAIhD,SAASiD,MAAMC,aACxBzC,IAAI,eAOrBmC,EAAOO,IAASN,uBACd5C,MAAWA,eAEb2B,SAASwB,KAAKC,YAAYT,MA2DvB,CAACjB,EAAoBR,IACxBJ,aAAgB,WACd,IAAKY,IAAuBC,SAASC,cAAc,aAAeJ,EAAQ,CACxE,IAAM6B,EAAY1B,SAASkB,cAAc,UACzCQ,EAAUC,GAAK,UACfD,EAAUH,IAAMhD,IAAqB,wBACrCmD,EAAUE,OAAQ,EAClBF,EAAUG,OAAS,iBAChBrC,OAAesC,wBAAftC,OAAesC,0BAElB9B,SAAS+B,KAAKC,OAAON,MAEtB,CAAC3B,IACJZ,aAAgB,WACd,IAAM8C,EAAW,SAACC,GAChB,IACE,IAAMC,EAAOhC,KAAKC,MAAM8B,EAAMC,MACV,iBAAhBA,EAAKC,QACP9B,EAAwB6B,EAAK9B,sBAE/B,YAGJ,OADAb,OAAO6C,iBAAiB,UAAWJ,GAC5B,WAAA,OAAMzC,OAAO8C,oBAAoB,UAAWL,MAClD,KACE1C,EACH,OAAO,KAET,GAAIG,GAAYG,EAAQ,CACtB,IAAI0C,EAASvC,SAASC,cAAc,gCAC/BsC,KACHA,EAASvC,SAASkB,cAAc,QACzBS,GAAK,cACZY,EAAOC,UAAUC,IAAI,mBACrBzC,SAASwB,KAAKC,YAAYc,IAE5B,IAAMG,IAAsBhD,GACxB,CACEiD,cAAezC,EAAarB,IAAI,iBAChC+D,eAAgBvC,EAChBwC,cAAe3C,EAAarB,IAAI,gBAGtC,OAAOiE,eACL3D,gBAAC4D,GAAcC,OAAQlE,GACrBK,gBAACD,EAAqB+D,UAASrF,MAAO8E,GACnC/E,EAAgBkB,QAGrB0D,EACA,eAGJ,OAAIxC,GAAsBP,OAAOC,SAAWD,OAExCL,0BACEoC,sEAAuE2B,mBACrE9E,SAASiD,MAEX8B,MAAO,CACLC,MAAO,QACPC,OAAQ,QACRC,OAAQ,OACRC,SAAU,QACVC,IAAK,EACLC,KAAM,EACNC,OAAQ,YAKT,SAsBIC,EAAqE,SAChFC,GAEA,IAAQC,EAAqBD,EAArBC,mBACgB1E,WACtB,MADKH,OAAM8E,OAMb,OAHA3E,aAAgB,WACd2E,EAAQ3E,gBAACE,WACR,IAEDF,iCACI0E,GAAoB1E,gBAAC4E,QACtB/E,IAMDgF,EAA8C,YACpCC,EAA4BhC,GAE1C,OADA+B,EAAqBrD,KAAKsB,GACnB,WACL,IAAMrB,EAAQoD,EAAqBnD,QAAQoB,GACvCrB,GAAS,GACXoD,EAAqBlD,OAAOF,EAAO,IAGxC,IAUKmC,sBAIJ,WAAYa,SAEM,OADhBM,cAAMN,UACDO,MAAQ,qFACdpB,EAEMqB,yBAAP,SAAgCC,GAC9B,MAAO,CAAEA,MAAAA,IACV,kBAYA,OAZAC,EAEDC,kBAAA,SAAkBF,GAChBL,EAAqBhG,SAAQ,SAACiE,GAAQ,OAAKA,EAASoC,OACrDC,EAEDE,OAAA,WACE,OAAI3G,KAAKsG,MAAME,MACNlF,wCAAgBtB,KAAKsG,MAAME,MAAMI,SAEjCtF,gCAAGtB,KAAK+F,MAAMc,cArBCvF,aA0B5B,SAAS4E,IAEL,OAAO,KGlRJ,ICUMY,EAAcC,qBAAoCC,YAO/CC,EAAWC,GACzB,wBAAyBA,WAGXC,EAAYC,GAC1B,OAAOA,WAGOC,EACdC,EACAC,GAEA,GAAKA,EAAL,CAIA,IADA,MAAIC,EAAUF,wrBACIC,EAASE,MAAM,qBAAM,CAAA,MACrCD,WAAUA,UAAAE,WAEZ,OAAOF,YAKOG,EAAYJ,GAE1B,OAAOF,EADSO,IACcL,YAGhBM,EAAaC,YAAAA,IAAAA,EAA0B,IACrD,IAAMR,EAAUM,IAChB,OAAOG,OAAOC,YACZD,OAAOE,QAAQH,GACZI,QAAO,YAAe,wBACtBC,KAAI,YAAe,ODnDL,WAAH,2BAAwBC,2BAAAA,kBAAO,OAAQA,ECmDzBC,MAAWhB,EAAcC,aAIzD,SAAgBM,IACd,OAAOU,aAAWxB,YAuBJyB,aACdrB,IAAAA,KACA5C,IAAAA,KACAkE,IAAAA,OACAC,IAAAA,MACA5B,IAAAA,SAEM6B,WAAcd,OAAgB,GACpC,OAAKV,EAID5F,gBAACwF,EAAY1B,UACXrF,WACK2I,UACFxB,GAAO5C,IACP2C,EAAWC,IAAoB,CAAEsB,OAAAA,EAAQC,MAAAA,QAG3C5B,GAVEvF,gCAAGuF,YAsBE8B,SACd9B,IAAAA,SAAQ+B,IACRC,OAAAA,aAAS,KAAEC,IACXC,MAAAA,aAAQ,KAEFC,EAAOpB,KAAgB,GAC7B,OACEtG,gBAACiH,GACCrB,KAAM,SACN5C,UAAW0E,EAAKH,OAAWA,GAC3BJ,MAAO,wBAEPnH,gBAACiH,GACCrB,KAAM,QACN5C,UAAW0E,EAAKD,MAAUA,GAC1BN,MAAO,yBAEN5B,aAMOoC,KAMd,OAAOpC,IALPA,UAIae,KCxIf,IAAMlI,EAAOC,oBA2CGuJ,EAAgBC,EAAkB/B,GAChD1H,EAAK0J,yBAAyBtG,KAAK,CAAEqG,QAAAA,EAAS/B,KAAAA,IAHhD1H,EAAK0J,yBAA2B,OCvCnBC,EAAuB/H,EAAMyF,mBAExCC,YAEcsC,EAAsBvD,GAKpC,IAAQwD,EAAmCxD,EAAnCwD,YAAa1C,EAAsBd,EAAtBc,SAAU2C,EAAYzD,EAAZyD,QACzBC,EAAoBnI,EAAMoI,SAC9B,WAAA,OACE3B,OAAOC,YACLD,OAAOE,QAAQuB,GAASrB,KAAI,YAAU,MAAM,CACvCoB,uBAIT,CAACA,EAAaC,IAEhB,OACElI,gBAAC+H,EAAqBjE,UAASrF,MAAO0J,GACnC5C,GAKP,SAAgB8C,UACd,gBAAOrI,EAAMgH,WAAWe,MAAyB,GC1BnD,IAAM3J,EAAOC,oBAklBWiK,EACtBC,EACAzC,GAIE1H,EAAKoK,2BAA2BC,MAC9B,SAACC,GAAwB,OACvBA,EAAEH,YAAcA,GAAaG,EAAE5C,KAAKF,OAASE,EAAKF,SAKxDxH,EAAKoK,2BAA2BhH,KAAK,CAAE+G,UAAAA,EAAWzC,KAAAA,IAjBb,MAAnC1H,EAAKoK,6BACPpK,EAAKoK,2BAA6B,IC1kBpC,IAAMpK,EAAOC,oBAkGWsK,EAEtBJ,EAAczC,GAGZ1H,EAAKwK,yBAAyBH,MAC5B,SAACC,GAA4B,OAC3BA,EAAEH,YAAcA,GAAaG,EAAE5C,KAAKF,OAASE,EAAKF,SAKxDxH,EAAKwK,yBAAyBpH,KAAK,CAAE+G,UAAAA,EAAWzC,KAAAA,IAhBb,MAAjC1H,EAAKwK,2BACPxK,EAAKwK,yBAA2B,ICtFlC,IAAMxK,EAAOC,oBAMWwK,EAAcC,GACpC1K,EAAK2K,uBAAuBvH,KAAKsH,GALA,MAA/B1K,EAAK2K,yBACP3K,EAAK2K,uBAAyB,ICvBhC,QAAM3K,EAAOC,oBA8BW2K,EAAcC,EAAenD,GACnD1H,EAAK8K,uBAAuB1H,KAAK,CAC/ByH,MAAAA,EACAnD,KAAAA,aCjBoBqD,EAAmB1H,EAAyB2H,GAClE,OAAOC,EAAkB5H,EAAc2H,GDSN,MAA/BhL,EAAK8K,yBACP9K,EAAK8K,uBAAyB,ICPhC,IAAIG,EAA4C,SAC9C5H,EACA2H,GAEA,OAAIE,MAAMC,QAAQH,GACTA,EAAIvC,KAAI,SAAC2C,GAAC,OAAKH,EAAkB5H,EAAc+H,MAEpDJ,GAAOK,iBAAeL,IAAuB,iBAARA,EAChCM,eAAaN,GAEfA,GAGHhL,EAAOC,WACAsL,iBACXvL,YAAAA,EAAMwL,cAANC,EAAaF,wBACb,SAAUG,GACRT,EAAoBS,6aCzBlB1L,EAAOC,WAEK,MAAdD,EAAKwL,QAMPxL,EAAKwL,SACH5J,MAAAA,EACA2D,SAAAA,EACAoG,aAAAA,EACAC,WAAAA,EACAC,YCzBuB,UD0BvBC,UAAW,CACTtK,mBAAAA,EACAkF,4BAAAA,EACA6E,qBAAAA,GAIF/J,mBAAAA,EACAkF,4BAAAA,EACA6E,qBAAAA,GACGK"}