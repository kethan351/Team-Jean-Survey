'use client';'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var PlasmicQuery = require('@plasmicapp/query');
var React = require('react');
var React__default = _interopDefault(React);
var ReactDOM = require('react-dom');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function isString(x) {
  return typeof x === "string";
}
function ensure(x, msg) {
  if (msg === void 0) {
    msg = "";
  }
  if (x === null || x === undefined) {
    debugger;
    msg = (isString(msg) ? msg : msg()) || "";
    throw new Error("Value must not be undefined or null" + (msg ? "- " + msg : ""));
  } else {
    return x;
  }
}

function useForceUpdate() {
  var _useState = React.useState(0),
    setTick = _useState[1];
  var update = React.useCallback(function () {
    setTick(function (tick) {
      return tick + 1;
    });
  }, []);
  return update;
}

var root = globalThis;
if (root.__PlasmicHostVersion == null) {
  root.__PlasmicHostVersion = "2";
}
var rootChangeListeners = [];
var PlasmicRootNodeWrapper = function PlasmicRootNodeWrapper(value) {
  var _this = this;
  this.value = value;
  this.set = function (val) {
    _this.value = val;
    rootChangeListeners.forEach(function (f) {
      return f();
    });
  };
  this.get = function () {
    return _this.value;
  };
};
var plasmicRootNode = /*#__PURE__*/new PlasmicRootNodeWrapper(null);
function getHashParams() {
  return new URLSearchParams(location.hash.replace(/^#/, "?"));
}
function getPlasmicOrigin() {
  var params = getHashParams();
  return ensure(params.get("origin"), "Missing information from Plasmic window.");
}
function getStudioHash() {
  var hashParams = getHashParams();
  if (hashParams.has("studioHash")) {
    return hashParams.get("studioHash");
  }
  var urlParams = new URL(location.href).searchParams;
  return urlParams.get("studio-hash");
}
function renderStudioIntoIframe() {
  var script = document.createElement("script");
  var plasmicOrigin = getPlasmicOrigin();
  var hash = getStudioHash();
  script.src = plasmicOrigin + "/static/js/studio" + (hash ? "." + hash + ".js" : ".js");
  document.body.appendChild(script);
}
var renderCount = 0;
function setPlasmicRootNode(node) {
  // Keep track of renderCount, which we use as key to ErrorBoundary, so
  // we can reset the error on each render
  renderCount++;
  plasmicRootNode.set(node);
}
/**
 * React context to detect whether the component is rendered on Plasmic editor.
 * If not, return false.
 * If so, return an object with more information about the component
 */
var PlasmicCanvasContext = /*#__PURE__*/React.createContext(false);
var usePlasmicCanvasContext = function usePlasmicCanvasContext() {
  return React.useContext(PlasmicCanvasContext);
};
function _PlasmicCanvasHost() {
  var _location$hash, _location$hash2;
  // If window.parent is null, then this is a window whose containing iframe
  // has been detached from the DOM (for the top window, window.parent === window).
  // In that case, we shouldn't do anything.  If window.parent is null, by the way,
  // location.hash will also be null.
  var isFrameAttached = !!window.parent;
  var isCanvas = !!((_location$hash = location.hash) != null && _location$hash.match(/\bcanvas=true\b/));
  var isLive = !!((_location$hash2 = location.hash) != null && _location$hash2.match(/\blive=true\b/)) || !isFrameAttached;
  var shouldRenderStudio = isFrameAttached && !document.querySelector("#plasmic-studio-tag") && !isCanvas && !isLive;
  var locationHash = new URLSearchParams(location.hash);
  var _React$useState = React.useState(function () {
      var _locationHash$get;
      return JSON.parse((_locationHash$get = locationHash.get("globalVariants")) != null ? _locationHash$get : "{}");
    }),
    activeGlobalVariants = _React$useState[0],
    setActiveGlobalVariants = _React$useState[1];
  var forceUpdate = useForceUpdate();
  React.useLayoutEffect(function () {
    rootChangeListeners.push(forceUpdate);
    return function () {
      var index = rootChangeListeners.indexOf(forceUpdate);
      if (index >= 0) {
        rootChangeListeners.splice(index, 1);
      }
    };
  }, [forceUpdate]);
  React.useEffect(function () {
    if (shouldRenderStudio && isFrameAttached && window.parent !== window) {
      renderStudioIntoIframe();
    }
  }, [shouldRenderStudio, isFrameAttached]);
  React.useEffect(function () {
    if (!shouldRenderStudio && !document.querySelector("#getlibs") && isLive) {
      var scriptElt = document.createElement("script");
      scriptElt.id = "getlibs";
      scriptElt.src = getPlasmicOrigin() + "/static/js/getlibs.js";
      scriptElt.async = false;
      scriptElt.onload = function () {
        window.__GetlibsReadyResolver == null ? void 0 : window.__GetlibsReadyResolver();
      };
      document.head.append(scriptElt);
    }
  }, [shouldRenderStudio]);
  React.useEffect(function () {
    var listener = function listener(event) {
      try {
        var data = JSON.parse(event.data);
        if (data.source === "canvas-frame") {
          setActiveGlobalVariants(data.activeGlobalVariants);
        }
      } catch (_unused) {}
    };
    window.addEventListener("message", listener);
    return function () {
      return window.removeEventListener("message", listener);
    };
  }, []);
  if (!isFrameAttached) {
    return null;
  }
  if (isCanvas || isLive) {
    var appDiv = document.querySelector("#plasmic-app.__wab_user-body");
    if (!appDiv) {
      appDiv = document.createElement("div");
      appDiv.id = "plasmic-app";
      appDiv.classList.add("__wab_user-body");
      document.body.appendChild(appDiv);
    }
    var plasmicContextValue = isCanvas ? {
      componentName: locationHash.get("componentName"),
      globalVariants: activeGlobalVariants,
      interactive: !!locationHash.get("interactive")
    } : false;
    return ReactDOM.createPortal(React.createElement(ErrorBoundary, {
      key: "" + renderCount
    }, React.createElement(PlasmicCanvasContext.Provider, {
      value: plasmicContextValue
    }, plasmicRootNode.get())), appDiv, "plasmic-app");
  }
  if (shouldRenderStudio && window.parent === window) {
    return React.createElement("iframe", {
      src: "https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=" + encodeURIComponent(location.href),
      style: {
        width: "100vw",
        height: "100vh",
        border: "none",
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: 99999999
      }
    });
  }
  return null;
}
var PlasmicCanvasHost = function PlasmicCanvasHost(props) {
  var enableWebpackHmr = props.enableWebpackHmr;
  var _React$useState2 = React.useState(null),
    node = _React$useState2[0],
    setNode = _React$useState2[1];
  React.useEffect(function () {
    setNode(React.createElement(_PlasmicCanvasHost, null));
  }, []);
  return React.createElement(React.Fragment, null, !enableWebpackHmr && React.createElement(DisableWebpackHmr, null), node);
};
var renderErrorListeners = [];
function registerRenderErrorListener(listener) {
  renderErrorListeners.push(listener);
  return function () {
    var index = renderErrorListeners.indexOf(listener);
    if (index >= 0) {
      renderErrorListeners.splice(index, 1);
    }
  };
}
var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);
  function ErrorBoundary(props) {
    var _this2;
    _this2 = _React$Component.call(this, props) || this;
    _this2.state = {};
    return _this2;
  }
  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };
  var _proto = ErrorBoundary.prototype;
  _proto.componentDidCatch = function componentDidCatch(error) {
    renderErrorListeners.forEach(function (listener) {
      return listener(error);
    });
  };
  _proto.render = function render() {
    if (this.state.error) {
      return React.createElement("div", null, "Error: ", "" + this.state.error.message);
    } else {
      return React.createElement(React.Fragment, null, this.props.children);
    }
  };
  return ErrorBoundary;
}(React.Component);
function DisableWebpackHmr() {
  return React.createElement("script", {
    type: "text/javascript",
    dangerouslySetInnerHTML: {
      __html: "\n      if (typeof window !== \"undefined\") {\n        const RealEventSource = window.EventSource;\n        window.EventSource = function(url, config) {\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\n            console.warn(\"Plasmic: disabled EventSource request for\", url);\n            return {\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\n            };\n          } else {\n            return new RealEventSource(url, config);\n          }\n        }\n      }\n      "
    }
  });
}

var tuple = function tuple() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};

var DataContext = /*#__PURE__*/React.createContext(undefined);
function mkMetaName(name) {
  return "__plasmic_meta_" + name;
}
function mkMetaValue(meta) {
  return meta;
}
function applySelector(rawData, selector) {
  if (!selector) {
    return undefined;
  }
  var curData = rawData;
  for (var _iterator = _createForOfIteratorHelperLoose(selector.split(".")), _step; !(_step = _iterator()).done;) {
    var _curData;
    var key = _step.value;
    curData = (_curData = curData) == null ? void 0 : _curData[key];
  }
  return curData;
}
function useSelector(selector) {
  var rawData = useDataEnv();
  return applySelector(rawData, selector);
}
function useSelectors(selectors) {
  if (selectors === void 0) {
    selectors = {};
  }
  var rawData = useDataEnv();
  return Object.fromEntries(Object.entries(selectors).filter(function (_ref) {
    var key = _ref[0],
      selector = _ref[1];
    return !!key && !!selector;
  }).map(function (_ref2) {
    var key = _ref2[0],
      selector = _ref2[1];
    return tuple(key, applySelector(rawData, selector));
  }));
}
function useDataEnv() {
  return React.useContext(DataContext);
}
function DataProvider(_ref3) {
  var _useDataEnv;
  var name = _ref3.name,
    data = _ref3.data,
    hidden = _ref3.hidden,
    label = _ref3.label,
    children = _ref3.children;
  var existingEnv = (_useDataEnv = useDataEnv()) != null ? _useDataEnv : {};
  if (!name) {
    return React__default.createElement(React__default.Fragment, null, children);
  } else {
    var _extends2;
    return React__default.createElement(DataContext.Provider, {
      value: _extends({}, existingEnv, (_extends2 = {}, _extends2[name] = data, _extends2[mkMetaName(name)] = mkMetaValue({
        hidden: hidden,
        label: label
      }), _extends2))
    }, children);
  }
}
function PageParamsProvider(_ref4) {
  var children = _ref4.children,
    _ref4$params = _ref4.params,
    params = _ref4$params === void 0 ? {} : _ref4$params,
    _ref4$query = _ref4.query,
    query = _ref4$query === void 0 ? {} : _ref4$query;
  var $ctx = useDataEnv() || {};
  return React__default.createElement(DataProvider, {
    name: "params",
    data: _extends({}, $ctx.params, params),
    label: "Page URL path params"
  }, React__default.createElement(DataProvider, {
    name: "query",
    data: _extends({}, $ctx.query, query),
    label: "Page URL query params"
  }, children));
}
function DataCtxReader(_ref5) {
  var children = _ref5.children;
  var $ctx = useDataEnv();
  return children($ctx);
}

var root$1 = globalThis;
root$1.__PlasmicFetcherRegistry = [];
function registerFetcher(fetcher, meta) {
  root$1.__PlasmicFetcherRegistry.push({
    fetcher: fetcher,
    meta: meta
  });
}

var GlobalActionsContext = /*#__PURE__*/React__default.createContext(undefined);
function GlobalActionsProvider(props) {
  var contextName = props.contextName,
    children = props.children,
    actions = props.actions;
  var namespacedActions = React__default.useMemo(function () {
    return Object.fromEntries(Object.entries(actions).map(function (_ref) {
      var key = _ref[0],
        val = _ref[1];
      return [contextName + "." + key, val];
    }));
  }, [contextName, actions]);
  return React__default.createElement(GlobalActionsContext.Provider, {
    value: namespacedActions
  }, children);
}
function useGlobalActions() {
  var _React$useContext;
  return (_React$useContext = React__default.useContext(GlobalActionsContext)) != null ? _React$useContext : {};
}

var root$2 = globalThis;
if (root$2.__PlasmicComponentRegistry == null) {
  root$2.__PlasmicComponentRegistry = [];
}
function registerComponent(component, meta) {
  // Check for duplicates
  if (root$2.__PlasmicComponentRegistry.some(function (r) {
    return r.component === component && r.meta.name === meta.name;
  })) {
    return;
  }
  root$2.__PlasmicComponentRegistry.push({
    component: component,
    meta: meta
  });
}

var root$3 = globalThis;
if (root$3.__PlasmicContextRegistry == null) {
  root$3.__PlasmicContextRegistry = [];
}
function registerGlobalContext(component, meta) {
  // Check for duplicates
  if (root$3.__PlasmicContextRegistry.some(function (r) {
    return r.component === component && r.meta.name === meta.name;
  })) {
    return;
  }
  root$3.__PlasmicContextRegistry.push({
    component: component,
    meta: meta
  });
}

var root$4 = globalThis;
if (root$4.__PlasmicTokenRegistry == null) {
  root$4.__PlasmicTokenRegistry = [];
}
function registerToken(token) {
  root$4.__PlasmicTokenRegistry.push(token);
}

var root$5 = globalThis;
if (root$5.__PlasmicTraitRegistry == null) {
  root$5.__PlasmicTraitRegistry = [];
}
function registerTrait(trait, meta) {
  root$5.__PlasmicTraitRegistry.push({
    trait: trait,
    meta: meta
  });
}

var _root$__Sub$setRepeat, _root$__Sub;
function repeatedElement(index, elt) {
  return _repeatedElementFn(index, elt);
}
var _repeatedElementFn = function repeatedElementFn(index, elt) {
  if (Array.isArray(elt)) {
    return elt.map(function (v) {
      return _repeatedElementFn(index, v);
    });
  }
  if (elt && React.isValidElement(elt) && typeof elt !== "string") {
    return React.cloneElement(elt);
  }
  return elt;
};
var root$6 = globalThis;
var setRepeatedElementFn = (_root$__Sub$setRepeat = root$6 == null ? void 0 : (_root$__Sub = root$6.__Sub) == null ? void 0 : _root$__Sub.setRepeatedElementFn) != null ? _root$__Sub$setRepeat : function (fn) {
  _repeatedElementFn = fn;
};



var hostModule = {
  __proto__: null,
  PlasmicCanvasContext: PlasmicCanvasContext,
  PlasmicCanvasHost: PlasmicCanvasHost,
  usePlasmicCanvasContext: usePlasmicCanvasContext,
  unstable_registerFetcher: registerFetcher,
  registerComponent: registerComponent,
  registerGlobalContext: registerGlobalContext,
  registerToken: registerToken,
  registerTrait: registerTrait,
  repeatedElement: repeatedElement,
  DataContext: DataContext,
  mkMetaName: mkMetaName,
  mkMetaValue: mkMetaValue,
  applySelector: applySelector,
  useSelector: useSelector,
  useSelectors: useSelectors,
  useDataEnv: useDataEnv,
  DataProvider: DataProvider,
  PageParamsProvider: PageParamsProvider,
  DataCtxReader: DataCtxReader,
  GlobalActionsContext: GlobalActionsContext,
  GlobalActionsProvider: GlobalActionsProvider,
  useGlobalActions: useGlobalActions
};

var hostVersion = "1.0.111";

var root$7 = globalThis;
if (root$7.__Sub == null) {
  // Creating a side effect here by logging, so that vite won't
  // ignore this block for whatever reason. Hiding this for now
  // as users are complaining; will have to check if this has
  // been fixed with vite.
  // console.log("Plasmic: Setting up app host dependencies");
  root$7.__Sub = /*#__PURE__*/_extends({
    React: React,
    ReactDOM: ReactDOM,
    PlasmicQuery: PlasmicQuery,
    hostModule: hostModule,
    hostVersion: hostVersion,
    hostUtils: {
      setPlasmicRootNode: setPlasmicRootNode,
      registerRenderErrorListener: registerRenderErrorListener,
      setRepeatedElementFn: setRepeatedElementFn
    },
    // For backwards compatibility:
    setPlasmicRootNode: setPlasmicRootNode,
    registerRenderErrorListener: registerRenderErrorListener,
    setRepeatedElementFn: setRepeatedElementFn
  }, hostModule);
}

exports.DataContext = DataContext;
exports.DataCtxReader = DataCtxReader;
exports.DataProvider = DataProvider;
exports.GlobalActionsContext = GlobalActionsContext;
exports.GlobalActionsProvider = GlobalActionsProvider;
exports.PageParamsProvider = PageParamsProvider;
exports.PlasmicCanvasContext = PlasmicCanvasContext;
exports.PlasmicCanvasHost = PlasmicCanvasHost;
exports.applySelector = applySelector;
exports.mkMetaName = mkMetaName;
exports.mkMetaValue = mkMetaValue;
exports.registerComponent = registerComponent;
exports.registerGlobalContext = registerGlobalContext;
exports.registerToken = registerToken;
exports.registerTrait = registerTrait;
exports.repeatedElement = repeatedElement;
exports.unstable_registerFetcher = registerFetcher;
exports.useDataEnv = useDataEnv;
exports.useGlobalActions = useGlobalActions;
exports.usePlasmicCanvasContext = usePlasmicCanvasContext;
exports.useSelector = useSelector;
exports.useSelectors = useSelectors;
//# sourceMappingURL=host.cjs.development.js.map
