{"version":3,"file":"index.esm.js","sources":["../../src/registerComponent.ts"],"sourcesContent":["import {\n  CodeComponentElement,\n  CSSProperties,\n  PlasmicElement,\n} from \"./element-types\";\n\nconst root = globalThis as any;\n\nexport interface CanvasComponentProps<Data = any> {\n  /**\n   * This prop is only provided within the canvas of Plasmic Studio.\n   * Allows the component to set data to be consumed by the props' controls.\n   */\n  setControlContextData?: (data: Data) => void;\n}\n\ntype InferDataType<P> = P extends CanvasComponentProps<infer Data> ? Data : any;\n\n/**\n * Config option that takes the context (e.g., props) of the component instance\n * to dynamically set its value.\n */\nexport type ContextDependentConfig<P, R> = (\n  props: P,\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null\n) => R;\n\nexport interface PropTypeBase<P> {\n  displayName?: string;\n  description?: string;\n  helpText?: string;\n  /**\n   * If the user has chosen to use a dynamic expression for this prop, provide\n   * a hint as to the expected values that the expression should evaluate to.\n   * This hint will be displayed alongside the code editor.  You may use\n   * markdown in the text here.\n   */\n  exprHint?: string;\n  hidden?: ContextDependentConfig<P, boolean>;\n  readOnly?: boolean | ContextDependentConfig<P, boolean>;\n  advanced?: boolean;\n  disableDynamicValue?: boolean;\n}\n\nexport type DefaultValueOrExpr<P, T> =\n  | {\n      defaultExpr?: undefined;\n      defaultExprHint?: undefined;\n      defaultValue?: T;\n      defaultValueHint?: T | ContextDependentConfig<P, T | undefined>;\n    }\n  | {\n      defaultValue?: undefined;\n      defaultValueHint?: undefined;\n      defaultExpr?: string;\n      defaultExprHint?: string;\n    };\n\ntype StringTypeBase<P> = PropTypeBase<P> & DefaultValueOrExpr<P, string>;\n\nexport type StringType<P> =\n  | \"string\"\n  | ((\n      | {\n          type: \"string\";\n          control?: \"default\" | \"large\";\n        }\n      | {\n          type: \"code\";\n          lang: \"css\" | \"html\" | \"javascript\" | \"json\";\n        }\n      | {\n          type: \"richText\";\n        }\n      | {\n          type: \"color\";\n          /**\n           * If specified, and the user picks a color token in the Studio, then\n           * the value passed in as prop is a css variable reference, like\n           * `var(--TOKEN_ID)`, instead of the resolved hex value of the token.\n           * You should take care in using this in the proper css context --\n           * the css token is only defined if you are rendering under some\n           * Plasmic component in the DOM tree, which is usually the case,\n           * unless you are using a React portal.\n           */\n          keepCssVar?: boolean;\n        }\n      | {\n          type: \"cardPicker\";\n          modalTitle?:\n            | React.ReactNode\n            | ContextDependentConfig<P, React.ReactNode>;\n          options:\n            | {\n                value: string;\n                label?: string;\n                imgUrl: string;\n                footer?: React.ReactNode;\n              }[]\n            | ContextDependentConfig<\n                P,\n                {\n                  value: string;\n                  label?: string;\n                  imgUrl: string;\n                  footer?: React.ReactNode;\n                }[]\n              >;\n          showInput?: boolean | ContextDependentConfig<P, boolean>;\n          onSearch?: ContextDependentConfig<\n            P,\n            ((value: string) => void) | undefined\n          >;\n        }\n    ) &\n      StringTypeBase<P>);\n\nexport type BooleanType<P> =\n  | \"boolean\"\n  | ({\n      type: \"boolean\";\n    } & DefaultValueOrExpr<P, boolean> &\n      PropTypeBase<P>);\n\ntype GraphQLValue = {\n  query: string;\n  variables?: Record<string, any>;\n};\n\nexport type GraphQLType<P> = {\n  type: \"code\";\n  lang: \"graphql\";\n  endpoint: string | ContextDependentConfig<P, string>;\n  method?: string | ContextDependentConfig<P, string>;\n  headers?: object | ContextDependentConfig<P, object>;\n} & DefaultValueOrExpr<P, GraphQLValue> &\n  PropTypeBase<P>;\n\ntype NumberTypeBase<P> = PropTypeBase<P> &\n  DefaultValueOrExpr<P, number> & {\n    type: \"number\";\n  };\n\nexport type NumberType<P> =\n  | \"number\"\n  | ((\n      | {\n          control?: \"default\";\n          min?: number | ContextDependentConfig<P, number>;\n          max?: number | ContextDependentConfig<P, number>;\n        }\n      | {\n          control: \"slider\";\n          min: number | ContextDependentConfig<P, number>;\n          max: number | ContextDependentConfig<P, number>;\n          step?: number | ContextDependentConfig<P, number>;\n        }\n    ) &\n      NumberTypeBase<P>);\n\n/**\n * Expects defaultValue to be a JSON-compatible value\n */\nexport type JSONLikeType<P> =\n  | \"object\"\n  | ({\n      type: \"object\";\n      fields?: {\n        [p: string]: PropType<P>;\n      };\n    } & DefaultValueOrExpr<P, any> &\n      PropTypeBase<P>)\n  | ({\n      type: \"array\";\n      itemType?: {\n        type: \"object\";\n        fields: {\n          [p: string]: PropType<P>;\n        };\n        /**\n         * Optional function that generates a name for this item in the array\n         */\n        nameFunc?: (item: any) => string | undefined;\n      };\n    } & DefaultValueOrExpr<P, any[]> &\n      PropTypeBase<P>)\n  | ({\n      type: \"dataSource\";\n      dataSource: \"airtable\" | \"cms\";\n    } & PropTypeBase<P>);\n\ntype DataPickerValueType = string | number | (string | number)[];\n\nexport type DataPickerType<P> =\n  | ({\n      type: \"dataSelector\";\n      data:\n        | Record<string, any>\n        | ContextDependentConfig<P, Record<string, any>>;\n      alwaysShowValuePathAsLabel?: boolean;\n    } & DefaultValueOrExpr<P, DataPickerValueType> &\n      PropTypeBase<P>)\n  | ({\n      type: \"exprEditor\";\n      data:\n        | Record<string, any>\n        | ContextDependentConfig<P, Record<string, any>>;\n    } & DefaultValueOrExpr<P, DataPickerValueType> &\n      PropTypeBase<P>);\n\ninterface ChoiceTypeBase<P> extends PropTypeBase<P> {\n  type: \"choice\";\n  options:\n    | string[]\n    | {\n        label: string;\n        value: string | number | boolean;\n      }[]\n    | ContextDependentConfig<\n        P,\n        | string[]\n        | {\n            label: string;\n            value: string | number | boolean;\n          }[]\n      >;\n  allowSearch?: boolean;\n  filterOption?: boolean;\n  onSearch?: ContextDependentConfig<P, ((value: string) => void) | undefined>;\n}\n\nexport type ChoiceType<P> = (\n  | ({\n      multiSelect?: false;\n    } & DefaultValueOrExpr<P, string | number | boolean>)\n  | ({\n      multiSelect: true;\n    } & DefaultValueOrExpr<P, (string | number | boolean)[]>)\n  | ({\n      multiSelect: ContextDependentConfig<P, boolean>;\n    } & DefaultValueOrExpr<\n      P,\n      string | number | boolean | (string | number | boolean)[]\n    >)\n) &\n  ChoiceTypeBase<P>;\n\nexport interface ModalProps {\n  show?: boolean;\n  children?: React.ReactNode;\n  onClose: () => void;\n  style?: CSSProperties;\n}\n\ninterface CustomControlProps<P> {\n  componentProps: P;\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null;\n  value: any;\n  /**\n   * Sets the value to be passed to the prop. Expects a JSON-compatible value.\n   */\n  updateValue: (newVal: any) => void;\n  /**\n   * Full screen modal component\n   */\n  FullscreenModal: React.ComponentType<ModalProps>;\n  /**\n   * Modal component for the side pane\n   */\n  SideModal: React.ComponentType<ModalProps>;\n\n  /**\n   * The document that the component will be rendered into; instead of using\n   * `document` directly (for, say, `document.querySelector()` etc.), you\n   * should use this instead.\n   */\n  studioDocument: typeof document;\n}\nexport type CustomControl<P> = React.ComponentType<CustomControlProps<P>>;\n\n/**\n * Expects defaultValue to be a JSON-compatible value\n */\nexport type CustomType<P> =\n  | CustomControl<P>\n  | ({\n      type: \"custom\";\n      control: CustomControl<P>;\n    } & PropTypeBase<P> &\n      DefaultValueOrExpr<P, any>);\n\ntype SlotType<P> =\n  | \"slot\"\n  | ({\n      type: \"slot\";\n      /**\n       * The unique names of all code components that can be placed in the slot\n       */\n      allowedComponents?: string[];\n      /**\n       * Whether the \"empty slot\" placeholder should be hidden in the canvas.\n       */\n      hidePlaceholder?: boolean;\n      /**\n       * Whether the slot is repeated, i.e., is rendered multiple times using\n       * repeatedElement().\n       */\n      isRepeated?: boolean;\n\n      /**\n       * If slot is a render prop (accepts a function that takes in some\n       * arguments and returns some JSX), then specify the names of the\n       * arguments expected by the render prop function.\n       */\n      renderPropParams?: string[];\n    } & Omit<\n      DefaultValueOrExpr<P, PlasmicElement | PlasmicElement[]>,\n      \"defaultValueHint\" | \"defaultExpr\" | \"defaultExprHint\"\n    >);\n\ntype ImageUrlType<P> =\n  | \"imageUrl\"\n  | ({\n      type: \"imageUrl\";\n    } & DefaultValueOrExpr<P, string> &\n      PropTypeBase<P>);\n\nexport type PrimitiveType<P = any> = Extract<\n  StringType<P> | BooleanType<P> | NumberType<P> | JSONLikeType<P>,\n  String\n>;\n\ntype ControlTypeBase =\n  | {\n      editOnly?: false;\n    }\n  | {\n      editOnly: true;\n      /**\n       * The prop where the values should be mapped to\n       */\n      uncontrolledProp?: string;\n    };\n\nexport type SupportControlled<T> =\n  | Extract<T, String | CustomControl<any>>\n  | (Exclude<T, String | CustomControl<any>> & ControlTypeBase);\n\nexport type PropType<P> =\n  | SupportControlled<\n      | StringType<P>\n      | BooleanType<P>\n      | NumberType<P>\n      | JSONLikeType<P>\n      | ChoiceType<P>\n      | ImageUrlType<P>\n      | CustomType<P>\n      | GraphQLType<P>\n      | DataPickerType<P>\n    >\n  | SlotType<P>;\n\ntype RestrictPropType<T, P> = T extends string\n  ? SupportControlled<\n      | StringType<P>\n      | ChoiceType<P>\n      | JSONLikeType<P>\n      | ImageUrlType<P>\n      | CustomType<P>\n      | DataPickerType<P>\n    >\n  : T extends boolean\n  ? SupportControlled<\n      BooleanType<P> | JSONLikeType<P> | CustomType<P> | DataPickerType<P>\n    >\n  : T extends number\n  ? SupportControlled<\n      NumberType<P> | JSONLikeType<P> | CustomType<P> | DataPickerType<P>\n    >\n  : PropType<P>;\n\nexport interface ActionProps<P> {\n  componentProps: P;\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null;\n  studioOps: {\n    showModal: (\n      modalProps: Omit<ModalProps, \"onClose\"> & { onClose?: () => void }\n    ) => void;\n    refreshQueryData: () => void;\n    appendToSlot: (element: PlasmicElement, slotName: string) => void;\n    removeFromSlotAt: (pos: number, slotName: string) => void;\n    updateProps: (newValues: any) => void;\n  };\n  /**\n   * The document that the component will be rendered into; instead of using\n   * `document` directly (for, say, `document.querySelector()` etc.), you\n   * should use this instead.\n   */\n  studioDocument: typeof document;\n}\n\nexport type Action<P> =\n  | {\n      type: \"button-action\";\n      label: string;\n      onClick: (props: ActionProps<P>) => void;\n    }\n  | {\n      type: \"custom-action\";\n      control: React.ComponentType<ActionProps<P>>;\n    };\n\ntype DistributedKeyOf<T> = T extends any ? keyof T : never;\n\ninterface ComponentTemplate<P>\n  extends Omit<CodeComponentElement<P>, \"type\" | \"name\"> {\n  /**\n   * A preview picture for the template.\n   */\n  previewImg?: string;\n}\n\nexport interface ComponentTemplates<P> {\n  [name: string]: ComponentTemplate<P>;\n}\ninterface $State {\n  [key: string]: any;\n}\n\ninterface $StateSpec<T> {\n  // Whether this state is private, readonly, or writable in\n  // this component\n  type: \"private\" | \"readonly\" | \"writable\";\n  // if initial value is defined by a js expression\n  initFunc?: ($props: Record<string, any>, $state: $State) => T;\n\n  // if initial value is a hard-coded value\n  initVal?: T;\n  // Whether this state is private, readonly, or writable in\n  // this component\n\n  // If writable, there should be a valueProp that maps props[valueProp]\n  // to the value of the state\n  valueProp?: string;\n\n  // If writable or readonly, there should be an onChangeProp where\n  // props[onChangeProp] is invoked whenever the value changes\n  onChangeProp?: string;\n}\n\nexport interface ComponentMeta<P> {\n  /**\n   * Any unique string name used to identify that component. Each component\n   * should be registered with a different `meta.name`, even if they have the\n   * same name in the code.\n   */\n  name: string;\n  /**\n   * The name to be displayed for the component in Studio. Optional: if not\n   * specified, `meta.name` is used.\n   */\n  displayName?: string;\n  /**\n   * The description of the component to be shown in Studio.\n   */\n  description?: string;\n  /**\n   * The javascript name to be used when generating code. Optional: if not\n   * provided, `meta.name` is used.\n   */\n  importName?: string;\n  /**\n   * An object describing the component properties to be used in Studio.\n   * For each `prop`, there should be an entry `meta.props[prop]` describing\n   * its type.\n   */\n  props: { [prop in DistributedKeyOf<P>]?: RestrictPropType<P[prop], P> } & {\n    [prop: string]: PropType<P>;\n  };\n  /**\n   * WIP: An object describing the component states to be used in Studio.\n   */\n  unstable__states?: Record<string, $StateSpec<any>>;\n  /**\n   * An array describing the component actions to be used in Studio.\n   */\n  actions?: Action<P>[];\n  /**\n   * Whether style sections should be shown in Studio. For styles to work, the\n   * component must accept a `className` prop. If unset, defaults to true.\n   */\n  styleSections?: boolean;\n  /**\n   * Whether the element can be repeated in Studio. If unset, defaults to true.\n   */\n  isRepeatable?: boolean;\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   *  Whether the component is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n  /**\n   * The prop that expects the CSS classes with styles to be applied to the\n   * component. Optional: if not specified, Plasmic will expect it to be\n   * `className`. Notice that if the component does not accept CSS classes, the\n   * component will not be able to receive styles from the Studio.\n   */\n  classNameProp?: string;\n  /**\n   * The prop that receives and forwards a React `ref`. Plasmic only uses `ref`\n   * to interact with components, so it's not used in the generated code.\n   * Optional: If not provided, the usual `ref` is used.\n   */\n  refProp?: string;\n  /**\n   * Default styles to start with when instantiating the component in Plasmic.\n   */\n  defaultStyles?: CSSProperties;\n  /**\n   * Component templates to start with on Plasmic.\n   */\n  templates?: ComponentTemplates<P>;\n  /**\n   * Registered name of parent component, used for grouping related components.\n   */\n  parentComponentName?: string;\n  /**\n   * Whether the component can be used as an attachment to an element.\n   */\n  isAttachment?: boolean;\n  /**\n   * Whether the component provides data to its slots using DataProvider.\n   */\n  providesData?: boolean;\n\n  /**\n   * If specified, then Figma components with the specified names will be mapped\n   * to this component when you paste Figma content into Plasmic\n   */\n  figmaMappings?: {\n    figmaComponentName: string;\n  }[];\n\n  /**\n   * If true, when an instance of this component is added, the element\n   * will always be named by the name of this component.\n   */\n  alwaysAutoName?: boolean;\n\n  unstable__refActions?: Record<string, RefActionRegistration<P>>;\n}\n\nexport interface FunctionParam<P> {\n  name: string;\n  displayName?: string;\n  type: PropType<P>;\n}\n\nexport interface RefActionRegistration<P> {\n  displayName?: string;\n  description?: string;\n  parameters: FunctionParam<P>[];\n}\n\nexport interface ComponentRegistration {\n  component: React.ComponentType<any>;\n  meta: ComponentMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicComponentRegistry: ComponentRegistration[];\n  }\n}\n\nif (root.__PlasmicComponentRegistry == null) {\n  root.__PlasmicComponentRegistry = [];\n}\n\nexport default function registerComponent<T extends React.ComponentType<any>>(\n  component: T,\n  meta: ComponentMeta<React.ComponentProps<T>>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicComponentRegistry.some(\n      (r: ComponentRegistration) =>\n        r.component === component && r.meta.name === meta.name\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicComponentRegistry.push({ component, meta });\n}\n"],"names":[],"mappings":";AAMA,IAAM,IAAI,GAAG,UAAiB,CAAC;AA8kB/B,IAAI,IAAI,CAAC,0BAA0B,IAAI,IAAI,EAAE;IAC3C,IAAI,CAAC,0BAA0B,GAAG,EAAE,CAAC;CACtC;SAEuB,iBAAiB,CACvC,SAAY,EACZ,IAA4C;;IAG5C,IACE,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAClC,UAAC,CAAwB;QACvB,OAAA,CAAC,CAAC,SAAS,KAAK,SAAS,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;KAAA,CACzD,EACD;QACA,OAAO;KACR;IACD,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE,SAAS,WAAA,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;AAC5D;;;;"}